File Path: ./cmd/cli/main.go
File Name: main.go

===========================================

// cmd/cli/main.go
package main

import (
	"bytes"
	"crypto/rand"
	"encoding/json"
	"flag"
	"fmt"
	"github.com/cloudflare/bn256"
	"github.com/koushamad/election-system/pkg/blockchain"
	"github.com/koushamad/election-system/pkg/crypto"
	"github.com/koushamad/election-system/pkg/election"
	"github.com/koushamad/election-system/pkg/network"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"time"
)

func main() {
	// Command-line flags
	nodeCmd := flag.NewFlagSet("node", flag.ExitOnError)
	nodePort := nodeCmd.Int("port", 5000, "Port number for the node")
	nodeValidator := nodeCmd.Bool("validator", false, "Run as a validator node")

	createElectionCmd := flag.NewFlagSet("create-election", flag.ExitOnError)
	electionName := createElectionCmd.String("name", "", "Election name")
	candidatesStr := createElectionCmd.String("candidates", "", "Comma-separated list of candidates")
	startTime := createElectionCmd.String("start", "", "Start time (YYYY-MM-DD HH:MM)")
	endTime := createElectionCmd.String("end", "", "End time (YYYY-MM-DD HH:MM)")
	nodeAddr := createElectionCmd.String("node", "localhost:5000", "Node address to submit transaction")

	voteCmd := flag.NewFlagSet("vote", flag.ExitOnError)
	voteElectionID := voteCmd.String("election", "", "Election ID")
	voteCandidate := voteCmd.String("candidate", "", "Candidate name")
	voteNodeAddr := voteCmd.String("node", "localhost:5000", "Node address to submit vote")

	// Parse command
	if len(os.Args) < 2 {
		fmt.Println("Expected 'node', 'create-election', or 'vote' subcommands")
		os.Exit(1)
	}

	switch os.Args[1] {
	case "node":
		nodeCmd.Parse(os.Args[2:])
		startNode(*nodePort, *nodeValidator)
	case "create-election":
		createElectionCmd.Parse(os.Args[2:])
		if *electionName == "" || *candidatesStr == "" || *startTime == "" || *endTime == "" {
			fmt.Println("All flags are required: --name, --candidates, --start, --end")
			os.Exit(1)
		}
		createElection(*electionName, *candidatesStr, *startTime, *endTime, *nodeAddr)
	case "vote":
		voteCmd.Parse(os.Args[2:])
		if *voteElectionID == "" || *voteCandidate == "" {
			fmt.Println("All flags are required: --election, --candidate")
			os.Exit(1)
		}
		castVote(*voteElectionID, *voteCandidate, *voteNodeAddr)
	default:
		fmt.Println("Expected 'node', 'create-election', or 'vote' subcommands")
		os.Exit(1)
	}
}

func startNode(port int, isValidator bool) {
	// Generate node keys
	keyPair := crypto.GenerateKeys()

	// Initialize node
	node := blockchain.NewNode()
	node.IsValidator = isValidator
	node.Address = fmt.Sprintf("%x", keyPair.PublicKey.Marshal()[:8]) // Use first 8 bytes of public key as address

	// Start server
	server := network.NewServer(node, port)
	fmt.Printf("Node running on port %d (Validator: %v, Address: %s)\n",
		port, isValidator, node.Address)
	log.Fatal(server.Start())
}

func createElection(name, candidatesStr, startTimeStr, endTimeStr, nodeAddr string) {
	// Parse candidates
	candidates := strings.Split(candidatesStr, ",")
	if len(candidates) < 2 {
		fmt.Println("At least two candidates are required")
		os.Exit(1)
	}

	// Parse times
	startTime, err := time.Parse("2006-01-02 15:04", startTimeStr)
	if err != nil {
		fmt.Printf("Invalid start time format: %v\n", err)
		os.Exit(1)
	}

	endTime, err := time.Parse("2006-01-02 15:04", endTimeStr)
	if err != nil {
		fmt.Printf("Invalid end time format: %v\n", err)
		os.Exit(1)
	}

	// Generate election keys
	electionKeys := crypto.GenerateKeys()

	// Create election object
	electionID := fmt.Sprintf("election-%x", time.Now().Unix())
	electionCandidates := make([]election.Candidate, len(candidates))
	for i, name := range candidates {
		electionCandidates[i] = election.Candidate{
			ID:   fmt.Sprintf("candidate-%d", i+1),
			Name: name,
		}
	}

	newElection := election.Election{
		ID:         electionID,
		Name:       name,
		Candidates: electionCandidates,
		StartTime:  startTime,
		EndTime:    endTime,
		PublicKey:  electionKeys.PublicKey,
	}

	// Create transaction
	tx, err := blockchain.NewTransaction(blockchain.TxCreateElection, newElection)
	if err != nil {
		fmt.Printf("Failed to create transaction: %v\n", err)
		os.Exit(1)
	}

	// Sign transaction (in a real implementation)
	// tx.Sign(electionKeys.PrivateKey)

	// Submit to node
	txJSON, _ := json.Marshal(tx)
	resp, err := http.Post(fmt.Sprintf("http://%s/transactions", nodeAddr),
		"application/json", bytes.NewBuffer(txJSON))
	if err != nil {
		fmt.Printf("Failed to submit transaction: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		body, _ := ioutil.ReadAll(resp.Body)
		fmt.Printf("Failed to create election: %s\n", body)
		os.Exit(1)
	}

	fmt.Printf("Election created successfully with ID: %s\n", electionID)
	fmt.Printf("Save your private key for tallying: %x\n", electionKeys.PrivateKey)
}

func castVote(electionID, candidateName, nodeAddr string) {
	// Generate voter keys
	voterKeys := crypto.GenerateKeys()

	// Get election details from the blockchain
	resp, err := http.Get(fmt.Sprintf("http://%s/elections/%s", nodeAddr, electionID))
	if err != nil {
		fmt.Printf("Failed to get election details: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Println("Election not found")
		os.Exit(1)
	}

	var electionData election.Election
	json.NewDecoder(resp.Body).Decode(&electionData)

	// Find candidate ID
	var candidateID string
	for _, candidate := range electionData.Candidates {
		if candidate.Name == candidateName {
			candidateID = candidate.ID
			break
		}
	}

	if candidateID == "" {
		fmt.Printf("Candidate '%s' not found in election\n", candidateName)
		os.Exit(1)
	}

	// Create encrypted vote
	candidateIndex := 0
	for i, candidate := range electionData.Candidates {
		if candidate.ID == candidateID {
			candidateIndex = i + 1 // 1-based index for voting
			break
		}
	}

	ciphertext, err := crypto.EncryptVote(electionData.PublicKey, candidateIndex)
	if err != nil {
		fmt.Printf("Failed to encrypt vote: %v\n", err)
		os.Exit(1)
	}

	// Generate zero-knowledge proof
	r, _ := rand.Int(rand.Reader, bn256.Order) // Random value used in encryption
	proof := crypto.GenerateVoteProof(ciphertext, r, candidateIndex)

	// Create ballot
	ballot := election.Ballot{
		Ciphertext: ciphertext,
		ZKProof:    proof,
		VoterID:    fmt.Sprintf("%x", voterKeys.PublicKey.Marshal()[:8]), // Use first 8 bytes of public key as voter ID
	}

	// Create vote transaction
	voteData := struct {
		ElectionID string          `json:"election_id"`
		Ballot     election.Ballot `json:"ballot"`
	}{
		ElectionID: electionID,
		Ballot:     ballot,
	}

	tx, err := blockchain.NewTransaction(blockchain.TxCastVote, voteData)
	if err != nil {
		fmt.Printf("Failed to create transaction: %v\n", err)
		os.Exit(1)
	}

	// Sign transaction (in a real implementation)
	// tx.Sign(voterKeys.PrivateKey)

	// Submit to node
	txJSON, _ := json.Marshal(tx)
	resp, err = http.Post(fmt.Sprintf("http://%s/transactions", nodeAddr),
		"application/json", bytes.NewBuffer(txJSON))
	if err != nil {
		fmt.Printf("Failed to submit vote: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		body, _ := ioutil.ReadAll(resp.Body)
		fmt.Printf("Failed to cast vote: %s\n", body)
		os.Exit(1)
	}

	fmt.Println("Vote cast successfully!")
	fmt.Printf("Your vote receipt: %x\n", ballot.ZKProof[:8]) // First 8 bytes as receipt
}

===========================================

File Path: ./test/integration/network_test.go
File Name: network_test.go

===========================================

package integration

import (
	"bytes"
	"encoding/json"
	_ "fmt"
	"github.com/koushamad/election-system/pkg/blockchain"
	"github.com/koushamad/election-system/pkg/network"
	"github.com/koushamad/election-system/test/utils"
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestServerChainEndpoint(t *testing.T) {
	// Setup node and server
	node := utils.SetupTestNode()
	server := network.NewServer(node, 0) // Port 0 for testing

	// Create a test transaction and block
	election, _ := utils.CreateTestElection("Test Election", []string{"Alice", "Bob"})
	tx, _ := utils.CreateElectionTransaction(election)
	node.TransactionPool = append(node.TransactionPool, tx)
	node.CreateBlock()

	// Create test HTTP request
	req, err := http.NewRequest("GET", "/chain", nil)
	if err != nil {
		t.Fatal(err)
	}

	// Create response recorder
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(server.handleGetChain)

	// Serve HTTP request
	handler.ServeHTTP(rr, req)

	// Check status code
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("Handler returned wrong status code: got %v want %v", status, http.StatusOK)
	}

	// Check response body
	var responseChain blockchain.Chain
	err = json.Unmarshal(rr.Body.Bytes(), &responseChain)
	if err != nil {
		t.Fatalf("Failed to parse response: %v", err)
	}

	// Verify chain length
	if len(responseChain.Blocks) != 2 { // Genesis + 1 block
		t.Errorf("Expected 2 blocks in chain, got %d", len(responseChain.Blocks))
	}

	// Verify transaction in block
	if len(responseChain.Blocks[1].Transactions) != 1 {
		t.Errorf("Expected 1 transaction in block, got %d",
			len(responseChain.Blocks[1].Transactions))
	}
}

func TestServerTransactionEndpoint(t *testing.T) {
	// Setup node and server
	node := utils.SetupTestNode()
	server := network.NewServer(node, 0) // Port 0 for testing

	// Create a test transaction
	election, _ := utils.CreateTestElection("Test Election", []string{"Alice", "Bob"})
	tx, _ := utils.CreateElectionTransaction(election)

	// Convert transaction to JSON
	txJSON, err := json.Marshal(tx)
	if err != nil {
		t.Fatalf("Failed to marshal transaction: %v", err)
	}

	// Create test HTTP request
	req, err := http.NewRequest("POST", "/transactions", bytes.NewBuffer(txJSON))
	if err != nil {
		t.Fatal(err)
	}
	req.Header.Set("Content-Type", "application/json")

	// Create response recorder
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(server.handleTransactions)

	// Serve HTTP request
	handler.ServeHTTP(rr, req)

	// Check status code
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("Handler returned wrong status code: got %v want %v",
			status, http.StatusOK)
	}

	// Verify transaction was added to the chain
	// Note: In the current implementation, transactions are validated but not stored
	// This would need to be updated when proper transaction pooling is implemented
}

===========================================

File Path: ./test/integration/blockchain_test.go
File Name: blockchain_test.go

===========================================

package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/koushamad/election-system/pkg/blockchain"
	"github.com/koushamad/election-system/pkg/election"
	"github.com/koushamad/election-system/test/utils"
	"testing"
	"time"
)

// Existing tests remain unchanged...
func TestMultiNodeConsensus(t *testing.T) {
	// Create multiple nodes to simulate a network
	node1 := utils.SetupTestNode()
	node2 := utils.SetupTestNode()
	node3 := utils.SetupTestNode()

	// Create test election
	election, _ := utils.CreateTestElection("Presidential Election 2025", []string{"Alice", "Bob", "Charlie"})
	tx, err := utils.CreateElectionTransaction(election)
	if err != nil {
		t.Fatalf("Failed to create election transaction: %v", err)
	}

	// Add transaction to node1 and create block
	node1.TransactionPool = append(node1.TransactionPool, tx)
	block := node1.CreateBlock()

	// Verify block was created on node1
	if len(node1.Chain.Blocks) != 2 { // Genesis + new block
		t.Errorf("Expected 2 blocks in node1 chain, got %d", len(node1.Chain.Blocks))
	}

	// Simulate block propagation to other nodes
	err = node2.AddBlock(block)
	if err != nil {
		t.Errorf("Failed to add block to node2: %v", err)
	}

	err = node3.AddBlock(block)
	if err != nil {
		t.Errorf("Failed to add block to node3: %v", err)
	}

	// Verify all nodes have the same blockchain state
	if len(node2.Chain.Blocks) != 2 || len(node3.Chain.Blocks) != 2 {
		t.Errorf("Chain length mismatch across nodes: node1=%d, node2=%d, node3=%d",
			len(node1.Chain.Blocks), len(node2.Chain.Blocks), len(node3.Chain.Blocks))
	}

	// Verify block hash consistency across nodes
	if !bytes.Equal(node1.Chain.Blocks[1].Hash, node2.Chain.Blocks[1].Hash) ||
		!bytes.Equal(node1.Chain.Blocks[1].Hash, node3.Chain.Blocks[1].Hash) {
		t.Error("Block hash inconsistency across nodes")
	}
}

func TestBlockchainPersistence(t *testing.T) {
	// Create a node and add some blocks
	node := utils.SetupTestNode()

	// Create and add multiple transactions
	for i := 0; i < 3; i++ {
		election, _ := utils.CreateTestElection(
			fmt.Sprintf("Election %d", i),
			[]string{"Candidate A", "Candidate B"},
		)
		tx, _ := utils.CreateElectionTransaction(election)
		node.TransactionPool = append(node.TransactionPool, tx)
		node.CreateBlock()
	}

	// Serialize the blockchain to JSON (simulating persistence)
	chainData, err := json.Marshal(node.Chain)
	if err != nil {
		t.Fatalf("Failed to serialize blockchain: %v", err)
	}

	// Deserialize into a new chain (simulating loading from storage)
	var loadedChain blockchain.Chain
	err = json.Unmarshal(chainData, &loadedChain)
	if err != nil {
		t.Fatalf("Failed to deserialize blockchain: %v", err)
	}

	// Verify the loaded chain has the correct number of blocks
	if len(loadedChain.Blocks) != 4 { // Genesis + 3 blocks
		t.Errorf("Expected 4 blocks in loaded chain, got %d", len(loadedChain.Blocks))
	}

	// Verify block integrity in the loaded chain
	for i := 1; i < len(loadedChain.Blocks); i++ {
		block := loadedChain.Blocks[i]
		prevBlock := loadedChain.Blocks[i-1]

		// Verify block index
		if block.Index != prevBlock.Index+1 {
			t.Errorf("Block index mismatch at position %d", i)
		}

		// Verify previous hash
		if !bytes.Equal(block.PrevHash, prevBlock.Hash) {
			t.Errorf("Previous hash mismatch at block %d", i)
		}

		// Verify block hash is correct
		calculatedHash := block.CalculateHash()
		if !bytes.Equal(calculatedHash, block.Hash) {
			t.Errorf("Block hash mismatch at position %d", i)
		}
	}
}

func TestLedgerConsistency(t *testing.T) {
	// Create a node
	node := utils.SetupTestNode()

	// Create test election
	election, _ := utils.CreateTestElection("Local Election 2025", []string{"Alice", "Bob"})
	electionTx, _ := utils.CreateElectionTransaction(election)

	// Add election transaction and create block
	node.TransactionPool = append(node.TransactionPool, electionTx)
	node.CreateBlock()

	// Create and add votes
	for i := 0; i < 5; i++ {
		candidate := "Alice"
		if i%2 == 0 {
			candidate = "Bob"
		}

		ballot, _ := utils.CreateTestVote(election, candidate)
		voteTx, _ := utils.CreateVoteTransaction(election.ID, ballot)

		node.TransactionPool = append(node.TransactionPool, voteTx)
	}

	// Create block with votes
	node.CreateBlock()

	// Verify ledger contains all transactions
	var electionFound, votesFound bool
	var voteCount int

	// Check each block for transactions
	for _, block := range node.Chain.Blocks {
		for _, tx := range block.Transactions {
			if tx.Type == blockchain.TxCreateElection {
				// Verify election transaction
				var electionData election.Election
				json.Unmarshal(tx.Payload, &electionData)
				if electionData.ID == election.ID {
					electionFound = true
				}
			} else if tx.Type == blockchain.TxCastVote {
				// Verify vote transaction
				var voteData struct {
					ElectionID string          `json:"election_id"`
					Ballot     election.Ballot `json:"ballot"`
				}
				json.Unmarshal(tx.Payload, &voteData)
				if voteData.ElectionID == election.ID {
					voteCount++
				}
			}
		}
	}

	votesFound = voteCount == 5

	if !electionFound {
		t.Error("Election transaction not found in blockchain")
	}

	if !votesFound {
		t.Errorf("Expected 5 vote transactions, found %d", voteCount)
	}
}

func TestForkResolution(t *testing.T) {
	// Create two nodes with identical genesis blocks
	node1 := utils.SetupTestNode()
	node2 := utils.SetupTestNode()

	// Create different transactions for each node
	election1, _ := utils.CreateTestElection("Election Node1", []string{"Alice", "Bob"})
	tx1, _ := utils.CreateElectionTransaction(election1)

	election2, _ := utils.CreateTestElection("Election Node2", []string{"Charlie", "Dave"})
	tx2, _ := utils.CreateElectionTransaction(election2)

	// Add transactions and create blocks independently
	node1.TransactionPool = append(node1.TransactionPool, tx1)
	block1 := node1.CreateBlock()

	node2.TransactionPool = append(node2.TransactionPool, tx2)
	block2 := node2.CreateBlock()

	// Verify both nodes have different blocks at position 1
	if bytes.Equal(node1.Chain.Blocks[1].Hash, node2.Chain.Blocks[1].Hash) {
		t.Error("Expected different blocks, but hashes match")
	}

	// Create more blocks on node1 to make its chain longer
	for i := 0; i < 3; i++ {
		election, _ := utils.CreateTestElection(fmt.Sprintf("Extra Election %d", i), []string{"X", "Y"})
		tx, _ := utils.CreateElectionTransaction(election)
		node1.TransactionPool = append(node1.TransactionPool, tx)
		node1.CreateBlock()
	}

	// Verify node1 has a longer chain
	if len(node1.Chain.Blocks) <= len(node2.Chain.Blocks) {
		t.Errorf("Expected node1 to have longer chain: node1=%d, node2=%d",
			len(node1.Chain.Blocks), len(node2.Chain.Blocks))
	}

	// Simulate node2 receiving node1's chain
	originalNode2BlockCount := len(node2.Chain.Blocks)
	node2.ReplaceChain(node1.Chain)

	// Verify node2 adopted the longer chain
	if len(node2.Chain.Blocks) != len(node1.Chain.Blocks) {
		t.Errorf("Chain length mismatch after fork resolution: node1=%d, node2=%d",
			len(node1.Chain.Blocks), len(node2.Chain.Blocks))
	}

	// Verify node2's original block is no longer in its chain
	var originalBlockFound bool
	for _, block := range node2.Chain.Blocks {
		if bytes.Equal(block.Hash, block2.Hash) {
			originalBlockFound = true
			break
		}
	}

	if originalBlockFound {
		t.Error("Node2's original block should have been replaced")
	}

	t.Logf("Successfully resolved fork: node2 replaced its %d blocks with node1's %d blocks",
		originalNode2BlockCount, len(node1.Chain.Blocks))
}

func TestTransactionPoolConsistency(t *testing.T) {
	// Create a node
	node := utils.SetupTestNode()

	// Create multiple transactions
	txs := make([]*blockchain.Transaction, 0)
	for i := 0; i < 5; i++ {
		election, _ := utils.CreateTestElection(
			fmt.Sprintf("Election %d", i),
			[]string{"Candidate A", "Candidate B"},
		)
		tx, _ := utils.CreateElectionTransaction(election)
		txs = append(txs, tx)
	}

	// Add transactions to pool
	for _, tx := range txs {
		node.TransactionPool = append(node.TransactionPool, tx)
	}

	// Verify pool contains all transactions
	if len(node.TransactionPool) != 5 {
		t.Errorf("Expected 5 transactions in pool, got %d", len(node.TransactionPool))
	}

	// Create a block (should include transactions from pool)
	block := node.CreateBlock()

	// Verify block contains all transactions
	if len(block.Transactions) != 5 {
		t.Errorf("Expected 5 transactions in block, got %d", len(block.Transactions))
	}

	// Verify transaction pool is cleared
	if len(node.TransactionPool) != 0 {
		t.Errorf("Expected empty transaction pool after block creation, got %d transactions",
			len(node.TransactionPool))
	}

	// Add a duplicate transaction (that's already in a block)
	err := node.AddTransaction(txs[0])
	if err == nil {
		t.Error("Expected error when adding duplicate transaction, got nil")
	}
}

func TestTimestampOrdering(t *testing.T) {
	// Create a node
	node := utils.SetupTestNode()

	// Create multiple blocks with controlled timestamps
	var timestamps []int64

	for i := 0; i < 5; i++ {
		election, _ := utils.CreateTestElection(
			fmt.Sprintf("Election %d", i),
			[]string{"Candidate A", "Candidate B"},
		)
		tx, _ := utils.CreateElectionTransaction(election)
		node.TransactionPool = append(node.TransactionPool, tx)

		block := node.CreateBlock()
		timestamps = append(timestamps, block.Timestamp)

		// Ensure some time passes between blocks
		time.Sleep(100 * time.Millisecond)
	}

	// Verify timestamps are monotonically increasing
	for i := 1; i < len(timestamps); i++ {
		if timestamps[i] <= timestamps[i-1] {
			t.Errorf("Block timestamps not increasing: block[%d]=%d, block[%d]=%d",
				i-1, timestamps[i-1], i, timestamps[i])
		}
	}

	// Verify block timestamps match their index in the chain
	for i := 1; i < len(node.Chain.Blocks); i++ {
		block := node.Chain.Blocks[i]
		if block.Index != i {
			t.Errorf("Block index mismatch: expected %d, got %d", i, block.Index)
		}
	}
}

func TestLedgerDataRetrieval(t *testing.T) {
	// Create a node and populate with election and votes
	node := utils.SetupTestNode()

	// Create test election
	election, _ := utils.CreateTestElection("Presidential Election 2025", []string{"Alice", "Bob", "Charlie"})
	electionTx, _ := utils.CreateElectionTransaction(election)

	// Add election transaction and create block
	node.TransactionPool = append(node.TransactionPool, electionTx)
	node.CreateBlock()

	// Create votes with specific distribution: 3 for Alice, 2 for Bob, 1 for Charlie
	votes := map[string]int{
		"Alice":   3,
		"Bob":     2,
		"Charlie": 1,
	}

	for candidate, count := range votes {
		for i := 0; i < count; i++ {
			ballot, _ := utils.CreateTestVote(election, candidate)
			voteTx, _ := utils.CreateVoteTransaction(election.ID, ballot)
			node.TransactionPool = append(node.TransactionPool, voteTx)
		}
	}

	// Create block with votes
	node.CreateBlock()

	// Simulate election result tallying by scanning the blockchain
	results := make(map[string]int)

	// Find the election first
	var electionData election.Election
	for _, block := range node.Chain.Blocks {
		for _, tx := range block.Transactions {
			if tx.Type == blockchain.TxCreateElection {
				err := json.Unmarshal(tx.Payload, &electionData)
				if err == nil && electionData.ID == election.ID {
					// Found the election, now count votes
					for _, block := range node.Chain.Blocks {
						for _, tx := range block.Transactions {
							if tx.Type == blockchain.TxCastVote {
								var voteData struct {
									ElectionID string           `json:"election_id"`
									Ballot     *election.Ballot `json:"ballot"`
								}

								if err := json.Unmarshal(tx.Payload, &voteData); err == nil {
									if voteData.ElectionID == election.ID {
										// In a real implementation, we would decrypt the vote
										// For this test, we'll use a mock decryption
										candidateIndex := mockDecryptVote(voteData.Ballot)
										if candidateIndex >= 0 && candidateIndex < len(electionData.Candidates) {
											candidateName := electionData.Candidates[candidateIndex].Name
											results[candidateName]++
										}
									}
								}
							}
						}
					}
					break
				}
			}
		}
	}

	// Verify vote counts match expected distribution
	for candidate, expectedCount := range votes {
		actualCount := results[candidate]
		if actualCount != expectedCount {
			t.Errorf("Vote count mismatch for %s: expected %d, got %d",
				candidate, expectedCount, actualCount)
		}
	}

	t.Logf("Successfully retrieved and tallied votes from blockchain: %v", results)
}

// Mock function to simulate vote decryption
// In a real implementation, this would use homomorphic decryption
func mockDecryptVote(ballot *election.Ballot) int {
	// For testing purposes, we'll determine the candidate based on a hash of the ballot data
	hash := ballot.ZKProof[0] % 3 // Use first byte of proof to determine candidate (0, 1, or 2)
	return int(hash)
}

func TestBlockCreation(t *testing.T) {
	node := utils.SetupTestNode()

	// Create a test transaction
	election, _ := utils.CreateTestElection("Test Election", []string{"Alice", "Bob"})
	tx, err := utils.CreateElectionTransaction(election)
	if err != nil {
		t.Fatalf("Failed to create election transaction: %v", err)
	}

	// Add transaction to node
	node.TransactionPool = append(node.TransactionPool, tx)

	// Create a block
	block := node.CreateBlock()

	// Verify block properties
	if block.Index != 1 { // 0 is genesis
		t.Errorf("Expected block index 1, got %d", block.Index)
	}

	if len(block.Transactions) != 1 {
		t.Errorf("Expected 1 transaction in block, got %d", len(block.Transactions))
	}

	// Verify transaction in block
	if string(block.Transactions[0].Hash) != string(tx.Hash) {
		t.Error("Transaction hash mismatch in block")
	}

	// Verify block is added to chain
	if len(node.Chain.Blocks) != 2 { // Genesis + new block
		t.Errorf("Expected 2 blocks in chain, got %d", len(node.Chain.Blocks))
	}

	// Verify transaction pool is cleared
	if len(node.TransactionPool) != 0 {
		t.Errorf("Expected empty transaction pool, got %d transactions", len(node.TransactionPool))
	}
}

func TestBlockchainIntegrity(t *testing.T) {
	node := utils.SetupTestNode()

	// Create multiple blocks
	for i := 0; i < 3; i++ {
		election, _ := utils.CreateTestElection(
			fmt.Sprintf("Test Election %d", i),
			[]string{"Alice", "Bob"},
		)
		tx, _ := utils.CreateElectionTransaction(election)
		node.TransactionPool = append(node.TransactionPool, tx)
		node.CreateBlock()
		time.Sleep(100 * time.Millisecond) // Ensure different timestamps
	}

	// Verify chain length
	if len(node.Chain.Blocks) != 4 { // Genesis + 3 blocks
		t.Errorf("Expected 4 blocks in chain, got %d", len(node.Chain.Blocks))
	}

	// Verify blockchain integrity (each block points to previous)
	for i := 1; i < len(node.Chain.Blocks); i++ {
		currentBlock := node.Chain.Blocks[i]
		prevBlock := node.Chain.Blocks[i-1]

		// Verify block index
		if currentBlock.Index != prevBlock.Index+1 {
			t.Errorf("Block index mismatch at position %d", i)
		}

		// Verify previous hash
		if string(currentBlock.PrevHash) != string(prevBlock.Hash) {
			t.Errorf("Previous hash mismatch at block %d", i)
		}

		// Verify block hash is correct
		calculatedHash := currentBlock.CalculateHash()
		if string(calculatedHash) != string(currentBlock.Hash) {
			t.Errorf("Block hash mismatch at position %d", i)
		}
	}
}

func TestTransactionValidation(t *testing.T) {
	chain := utils.SetupTestBlockchain()

	// Valid transaction
	election, _ := utils.CreateTestElection("Test Election", []string{"Alice", "Bob"})
	validTx, _ := utils.CreateElectionTransaction(election)

	err := chain.AddTransaction(validTx)
	if err != nil {
		t.Errorf("Failed to add valid transaction: %v", err)
	}

	// Invalid transaction (manually corrupt hash)
	invalidTx, _ := utils.CreateElectionTransaction(election)
	invalidTx.Hash = []byte("invalid-hash")

	// This should be rejected in a real implementation
	// Note: The current implementation always returns true for Validate()
	// This test will need to be updated when proper validation is implemented
	err = chain.AddTransaction(invalidTx)
	if err != nil {
		t.Logf("As expected, invalid transaction was rejected: %v", err)
	} else {
		t.Log("Warning: Invalid transaction was accepted. Implement proper validation.")
	}
}

===========================================

File Path: ./test/integration/election_test.go
File Name: election_test.go

===========================================

package integration

import (
	"github.com/cloudflare/bn256"
	"github.com/koushamad/election-system/pkg/blockchain"
	"github.com/koushamad/election-system/pkg/election"
	"github.com/koushamad/election-system/test/utils"
	"math/big"
	"testing"
	"time"
)

func TestElectionCreation(t *testing.T) {
	node := utils.SetupTestNode()

	// Create test election
	electionData, keys := utils.CreateTestElection(
		"Presidential Election 2025",
		[]string{"Alice", "Bob", "Charlie"},
	)

	// Verify election properties
	if electionData.Name != "Presidential Election 2025" {
		t.Errorf("Expected name 'Presidential Election 2025', got '%s'", electionData.Name)
	}

	if len(electionData.Candidates) != 3 {
		t.Errorf("Expected 3 candidates, got %d", len(electionData.Candidates))
	}

	// Verify election dates (should be in the future as of April 21, 2025)
	now := time.Date(2025, 4, 21, 12, 0, 0, 0, time.UTC)
	if !electionData.StartTime.After(now) {
		t.Errorf("Election start time should be in the future")
	}

	if !electionData.EndTime.After(electionData.StartTime) {
		t.Errorf("Election end time should be after start time")
	}

	// Create and add election transaction
	tx, err := utils.CreateElectionTransaction(electionData)
	if err != nil {
		t.Fatalf("Failed to create election transaction: %v", err)
	}

	node.TransactionPool = append(node.TransactionPool, tx)
	block := node.CreateBlock()

	// Verify transaction was included in block
	if len(block.Transactions) != 1 {
		t.Errorf("Expected 1 transaction in block, got %d", len(block.Transactions))
	}

	if block.Transactions[0].Type != blockchain.TxCreateElection {
		t.Errorf("Expected transaction type '%s', got '%s'",
			blockchain.TxCreateElection, block.Transactions[0].Type)
	}
}

func TestVoteCasting(t *testing.T) {
	node := utils.SetupTestNode()

	// Create test election
	electionData, _ := utils.CreateTestElection(
		"Local Election 2025",
		[]string{"Alice", "Bob", "Charlie"},
	)

	// Create and add election transaction
	electionTx, _ := utils.CreateElectionTransaction(electionData)
	node.TransactionPool = append(node.TransactionPool, electionTx)
	node.CreateBlock()

	// Create votes for different candidates
	candidates := []string{"Alice", "Bob", "Charlie"}
	for _, candidate := range candidates {
		// Create ballot
		ballot, err := utils.CreateTestVote(electionData, candidate)
		if err != nil {
			t.Fatalf("Failed to create vote for %s: %v", candidate, err)
		}

		// Verify ballot
		if !ballot.Validate() {
			t.Errorf("Ballot for %s failed validation", candidate)
		}

		// Create vote transaction
		voteTx, err := utils.CreateVoteTransaction(electionData.ID, ballot)
		if err != nil {
			t.Fatalf("Failed to create vote transaction: %v", err)
		}

		// Add to transaction pool
		node.TransactionPool = append(node.TransactionPool, voteTx)
	}

	// Create block with votes
	block := node.CreateBlock()

	// Verify all votes were included
	if len(block.Transactions) != 3 {
		t.Errorf("Expected 3 transactions in block, got %d", len(block.Transactions))
	}

	// Verify all transactions are vote transactions
	for _, tx := range block.Transactions {
		if tx.Type != blockchain.TxCastVote {
			t.Errorf("Expected transaction type '%s', got '%s'",
				blockchain.TxCastVote, tx.Type)
		}
	}
}

func TestZeroKnowledgeProofs(t *testing.T) {
	// Create test election
	electionData, _ := utils.CreateTestElection(
		"ZKP Test Election",
		[]string{"Alice", "Bob"},
	)

	// Create valid vote
	ballot, err := utils.CreateTestVote(electionData, "Alice")
	if err != nil {
		t.Fatalf("Failed to create vote: %v", err)
	}

	// Verify valid ballot passes validation
	if !ballot.Validate() {
		t.Error("Valid ballot failed verification")
	}

	// Create invalid proof
	invalidBallot := &election.Ballot{
		Ciphertext: ballot.Ciphertext,
		ZKProof:    make([]byte, 64), // Random invalid proof
		VoterID:    ballot.VoterID,
	}

	// Verify invalid ballot fails validation
	if invalidBallot.Validate() {
		t.Error("Invalid ballot passed verification")
	}

	// Test tampering with ciphertext
	tamperedBallot := &election.Ballot{
		Ciphertext: []*bn256.G1{
			new(bn256.G1).ScalarBaseMult(big.NewInt(999)),
			ballot.Ciphertext[1],
		},
		ZKProof: ballot.ZKProof,
		VoterID: ballot.VoterID,
	}

	// Verify tampered ballot fails validation
	if tamperedBallot.Validate() {
		t.Error("Tampered ballot passed verification")
	}
}

===========================================

File Path: ./test/utils/test_helpers.go
File Name: test_helpers.go

===========================================

package utils

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	"github.com/koushamad/election-system/pkg/blockchain"
	"github.com/koushamad/election-system/pkg/crypto"
	"github.com/koushamad/election-system/pkg/election"
	"time"

	"github.com/cloudflare/bn256"
)

// SetupTestBlockchain creates a blockchain with genesis block for testing
func SetupTestBlockchain() *blockchain.Chain {
	return blockchain.NewChain()
}

// SetupTestNode creates a node with initialized blockchain for testing
func SetupTestNode() *blockchain.Node {
	return blockchain.NewNode()
}

// CreateTestElection creates an election for testing purposes
func CreateTestElection(name string, candidates []string) (*election.Election, *crypto.KeyPair) {
	// Generate election keys
	electionKeys := crypto.GenerateKeys()

	// Create candidate objects
	electionCandidates := make([]election.Candidate, len(candidates))
	for i, name := range candidates {
		electionCandidates[i] = election.Candidate{
			ID:   fmt.Sprintf("candidate-%d", i+1),
			Name: name,
		}
	}

	// Create election with future dates (relative to April 2025)
	now := time.Date(2025, 4, 21, 12, 0, 0, 0, time.UTC)
	startTime := now.Add(24 * time.Hour)
	endTime := startTime.Add(48 * time.Hour)

	return &election.Election{
		ID:         fmt.Sprintf("election-%x", time.Now().Unix()),
		Name:       name,
		Candidates: electionCandidates,
		StartTime:  startTime,
		EndTime:    endTime,
		PublicKey:  electionKeys.PublicKey,
	}, electionKeys
}

// CreateTestVote creates a test vote for a specific candidate
func CreateTestVote(electionData *election.Election, candidateName string) (*election.Ballot, error) {
	// Find candidate index
	candidateIndex := 0
	found := false
	for i, candidate := range electionData.Candidates {
		if candidate.Name == candidateName {
			candidateIndex = i + 1 // 1-based index for voting
			found = true
			break
		}
	}

	if !found {
		return nil, fmt.Errorf("candidate '%s' not found", candidateName)
	}

	// Generate voter keys
	voterKeys := crypto.GenerateKeys()

	// Create encrypted vote
	ciphertext, err := crypto.EncryptVote(electionData.PublicKey, candidateIndex)
	if err != nil {
		return nil, err
	}

	// Generate random value for encryption (normally this would be saved)
	r, _ := rand.Int(rand.Reader, bn256.Order)

	// Generate zero-knowledge proof
	proof := crypto.GenerateVoteProof(ciphertext, r, candidateIndex)

	// Create ballot
	ballot := election.NewBallot(
		ciphertext,
		proof,
		fmt.Sprintf("%x", voterKeys.PublicKey.Marshal()[:8]),
	)

	return ballot, nil
}

// test/utils/test_helpers.go (partial update)
func CreateElectionTransaction(electionData *election.Election) (*blockchain.Transaction, error) {
	electionJSON, err := json.Marshal(electionData)
	if err != nil {
		return nil, err
	}

	tx := &blockchain.Transaction{
		ID:        blockchain.GenerateUUID(),
		Type:      blockchain.TxCreateElection,
		Payload:   electionJSON,
		Timestamp: time.Now().Unix(),
	}

	tx.Hash = tx.CalculateHash()
	return tx, nil
}

// CreateVoteTransaction creates a transaction for vote casting
func CreateVoteTransaction(electionID string, ballot *election.Ballot) (*blockchain.Transaction, error) {
	voteData := struct {
		ElectionID string           `json:"election_id"`
		Ballot     *election.Ballot `json:"ballot"`
	}{
		ElectionID: electionID,
		Ballot:     ballot,
	}

	voteJSON, err := json.Marshal(voteData)
	if err != nil {
		return nil, err
	}

	tx := &blockchain.Transaction{
		Type:    blockchain.TxCastVote,
		Payload: voteJSON,
	}

	tx.Hash = tx.CalculateHash()
	return tx, nil
}

===========================================

File Path: ./test/e2e/election_flow_test.go
File Name: election_flow_test.go

===========================================

package e2e

import (
	"encoding/json"
	"github.com/koushamad/election-system/pkg/blockchain"
	"github.com/koushamad/election-system/pkg/election"
	"github.com/koushamad/election-system/test/utils"
	"testing"
	"time"
)

func TestFullElectionFlow(t *testing.T) {
	// Initialize blockchain
	node := utils.SetupTestNode()

	// Step 1: Create election
	electionData, adminKeys := utils.CreateTestElection(
		"Presidential Election 2025",
		[]string{"Alice", "Bob", "Charlie"},
	)

	electionTx, err := utils.CreateElectionTransaction(electionData)
	if err != nil {
		t.Fatalf("Failed to create election transaction: %v", err)
	}

	node.TransactionPool = append(node.TransactionPool, electionTx)
	node.CreateBlock()

	// Verify election creation
	if len(node.Chain.Blocks) != 2 { // Genesis + election block
		t.Fatalf("Expected 2 blocks after election creation, got %d", len(node.Chain.Blocks))
	}

	// Step 2: Cast votes
	voters := []struct {
		ID        string
		Candidate string
	}{
		{"voter1", "Alice"},
		{"voter2", "Bob"},
		{"voter3", "Alice"},
		{"voter4", "Charlie"},
		{"voter5", "Alice"},
	}

	// Cast votes
	for _, voter := range voters {
		ballot, err := utils.CreateTestVote(electionData, voter.Candidate)
		if err != nil {
			t.Fatalf("Failed to create vote for %s: %v", voter.Candidate, err)
		}

		// Override voter ID for test
		ballot.VoterID = voter.ID

		voteTx, err := utils.CreateVoteTransaction(electionData.ID, ballot)
		if err != nil {
			t.Fatalf("Failed to create vote transaction: %v", err)
		}

		node.TransactionPool = append(node.TransactionPool, voteTx)
	}

	// Create block with votes
	node.CreateBlock()

	// Verify vote block
	voteBlock := node.Chain.Blocks[2]
	if len(voteBlock.Transactions) != 5 {
		t.Errorf("Expected 5 vote transactions, got %d", len(voteBlock.Transactions))
	}

	// Step 3: Test double voting prevention
	duplicateVoter := voters[0] // Try to vote again with voter1
	ballot, _ := utils.CreateTestVote(electionData, duplicateVoter.Candidate)
	ballot.VoterID = duplicateVoter.ID

	voteTx, _ := utils.CreateVoteTransaction(electionData.ID, ballot)
	node.TransactionPool = append(node.TransactionPool, voteTx)

	// Create another block
	node.CreateBlock()

	// In a proper implementation, the duplicate vote should be rejected
	// This test would need to be updated when proper validation is implemented

	// Step 4: Tally votes (homomorphically)
	// In a real implementation, this would use the homomorphic properties
	// For this test, we'll manually count

	// Extract votes from blockchain
	votes := make(map[string]int)
	for _, block := range node.Chain.Blocks {
		for _, tx := range block.Transactions {
			if tx.Type == blockchain.TxCastVote {
				var voteData struct {
					ElectionID string           `json:"election_id"`
					Ballot     *election.Ballot `json:"ballot"`
				}

				if err := json.Unmarshal(tx.Payload, &voteData); err != nil {
					continue
				}

				if voteData.ElectionID != electionData.ID {
					continue
				}

				// In a real implementation, we would decrypt the vote
				// For this test, we'll just count the ballots
				votes[voteData.Ballot.VoterID]++
			}
		}
	}

	// Verify we have the expected number of unique voters
	if len(votes) != 5 {
		t.Errorf("Expected 5 unique voters, got %d", len(votes))
	}

	// Step 5: Create tally transaction
	tallyResult := struct {
		ElectionID string         `json:"election_id"`
		Results    map[string]int `json:"results"`
		Timestamp  int64          `json:"timestamp"`
	}{
		ElectionID: electionData.ID,
		Results: map[string]int{
			"Alice":   3,
			"Bob":     1,
			"Charlie": 1,
		},
		Timestamp: time.Now().Unix(),
	}

	tallyJSON, _ := json.Marshal(tallyResult)
	tallyTx := &blockchain.Transaction{
		Type:    "tally_votes",
		Payload: tallyJSON,
	}
	tallyTx.Hash = tallyTx.CalculateHash()

	node.TransactionPool = append(node.TransactionPool, tallyTx)
	node.CreateBlock()

	// Verify tally block
	tallyBlock := node.Chain.Blocks[4]
	if len(tallyBlock.Transactions) != 1 {
		t.Errorf("Expected 1 tally transaction, got %d", len(tallyBlock.Transactions))
	}

	// Verify final blockchain state
	if len(node.Chain.Blocks) != 5 { // Genesis + election + votes + duplicate attempt + tally
		t.Errorf("Expected 5 blocks in final chain, got %d", len(node.Chain.Blocks))
	}

	t.Log("Full election flow completed successfully")
}

===========================================

File Path: ./vendor/golang.org/x/crypto/hkdf/hkdf.go
File Name: hkdf.go

===========================================

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package hkdf implements the HMAC-based Extract-and-Expand Key Derivation
// Function (HKDF) as defined in RFC 5869.
//
// HKDF is a cryptographic key derivation function (KDF) with the goal of
// expanding limited input keying material into one or more cryptographically
// strong secret keys.
package hkdf

import (
	"crypto/hmac"
	"errors"
	"hash"
	"io"
)

// Extract generates a pseudorandom key for use with Expand from an input secret
// and an optional independent salt.
//
// Only use this function if you need to reuse the extracted key with multiple
// Expand invocations and different context values. Most common scenarios,
// including the generation of multiple keys, should use New instead.
func Extract(hash func() hash.Hash, secret, salt []byte) []byte {
	if salt == nil {
		salt = make([]byte, hash().Size())
	}
	extractor := hmac.New(hash, salt)
	extractor.Write(secret)
	return extractor.Sum(nil)
}

type hkdf struct {
	expander hash.Hash
	size     int

	info    []byte
	counter byte

	prev []byte
	buf  []byte
}

func (f *hkdf) Read(p []byte) (int, error) {
	// Check whether enough data can be generated
	need := len(p)
	remains := len(f.buf) + int(255-f.counter+1)*f.size
	if remains < need {
		return 0, errors.New("hkdf: entropy limit reached")
	}
	// Read any leftover from the buffer
	n := copy(p, f.buf)
	p = p[n:]

	// Fill the rest of the buffer
	for len(p) > 0 {
		if f.counter > 1 {
			f.expander.Reset()
		}
		f.expander.Write(f.prev)
		f.expander.Write(f.info)
		f.expander.Write([]byte{f.counter})
		f.prev = f.expander.Sum(f.prev[:0])
		f.counter++

		// Copy the new batch into p
		f.buf = f.prev
		n = copy(p, f.buf)
		p = p[n:]
	}
	// Save leftovers for next run
	f.buf = f.buf[n:]

	return need, nil
}

// Expand returns a Reader, from which keys can be read, using the given
// pseudorandom key and optional context info, skipping the extraction step.
//
// The pseudorandomKey should have been generated by Extract, or be a uniformly
// random or pseudorandom cryptographically strong key. See RFC 5869, Section
// 3.3. Most common scenarios will want to use New instead.
func Expand(hash func() hash.Hash, pseudorandomKey, info []byte) io.Reader {
	expander := hmac.New(hash, pseudorandomKey)
	return &hkdf{expander, expander.Size(), info, 1, nil, nil}
}

// New returns a Reader, from which keys can be read, using the given hash,
// secret, salt and context info. Salt and info can be nil.
func New(hash func() hash.Hash, secret, salt, info []byte) io.Reader {
	prk := Extract(hash, secret, salt)
	return Expand(hash, prk, info)
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_linux_arm64.go
File Name: cpu_linux_arm64.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import (
	"strings"
	"syscall"
)

// HWCAP/HWCAP2 bits. These are exposed by Linux.
const (
	hwcap_FP       = 1 << 0
	hwcap_ASIMD    = 1 << 1
	hwcap_EVTSTRM  = 1 << 2
	hwcap_AES      = 1 << 3
	hwcap_PMULL    = 1 << 4
	hwcap_SHA1     = 1 << 5
	hwcap_SHA2     = 1 << 6
	hwcap_CRC32    = 1 << 7
	hwcap_ATOMICS  = 1 << 8
	hwcap_FPHP     = 1 << 9
	hwcap_ASIMDHP  = 1 << 10
	hwcap_CPUID    = 1 << 11
	hwcap_ASIMDRDM = 1 << 12
	hwcap_JSCVT    = 1 << 13
	hwcap_FCMA     = 1 << 14
	hwcap_LRCPC    = 1 << 15
	hwcap_DCPOP    = 1 << 16
	hwcap_SHA3     = 1 << 17
	hwcap_SM3      = 1 << 18
	hwcap_SM4      = 1 << 19
	hwcap_ASIMDDP  = 1 << 20
	hwcap_SHA512   = 1 << 21
	hwcap_SVE      = 1 << 22
	hwcap_ASIMDFHM = 1 << 23
	hwcap_DIT      = 1 << 24

	hwcap2_SVE2 = 1 << 1
	hwcap2_I8MM = 1 << 13
)

// linuxKernelCanEmulateCPUID reports whether we're running
// on Linux 4.11+. Ideally we'd like to ask the question about
// whether the current kernel contains
// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=77c97b4ee21290f5f083173d957843b615abbff2
// but the version number will have to do.
func linuxKernelCanEmulateCPUID() bool {
	var un syscall.Utsname
	syscall.Uname(&un)
	var sb strings.Builder
	for _, b := range un.Release[:] {
		if b == 0 {
			break
		}
		sb.WriteByte(byte(b))
	}
	major, minor, _, ok := parseRelease(sb.String())
	return ok && (major > 4 || major == 4 && minor >= 11)
}

func doinit() {
	if err := readHWCAP(); err != nil {
		// We failed to read /proc/self/auxv. This can happen if the binary has
		// been given extra capabilities(7) with /bin/setcap.
		//
		// When this happens, we have two options. If the Linux kernel is new
		// enough (4.11+), we can read the arm64 registers directly which'll
		// trap into the kernel and then return back to userspace.
		//
		// But on older kernels, such as Linux 4.4.180 as used on many Synology
		// devices, calling readARM64Registers (specifically getisar0) will
		// cause a SIGILL and we'll die. So for older kernels, parse /proc/cpuinfo
		// instead.
		//
		// See golang/go#57336.
		if linuxKernelCanEmulateCPUID() {
			readARM64Registers()
		} else {
			readLinuxProcCPUInfo()
		}
		return
	}

	// HWCAP feature bits
	ARM64.HasFP = isSet(hwCap, hwcap_FP)
	ARM64.HasASIMD = isSet(hwCap, hwcap_ASIMD)
	ARM64.HasEVTSTRM = isSet(hwCap, hwcap_EVTSTRM)
	ARM64.HasAES = isSet(hwCap, hwcap_AES)
	ARM64.HasPMULL = isSet(hwCap, hwcap_PMULL)
	ARM64.HasSHA1 = isSet(hwCap, hwcap_SHA1)
	ARM64.HasSHA2 = isSet(hwCap, hwcap_SHA2)
	ARM64.HasCRC32 = isSet(hwCap, hwcap_CRC32)
	ARM64.HasATOMICS = isSet(hwCap, hwcap_ATOMICS)
	ARM64.HasFPHP = isSet(hwCap, hwcap_FPHP)
	ARM64.HasASIMDHP = isSet(hwCap, hwcap_ASIMDHP)
	ARM64.HasCPUID = isSet(hwCap, hwcap_CPUID)
	ARM64.HasASIMDRDM = isSet(hwCap, hwcap_ASIMDRDM)
	ARM64.HasJSCVT = isSet(hwCap, hwcap_JSCVT)
	ARM64.HasFCMA = isSet(hwCap, hwcap_FCMA)
	ARM64.HasLRCPC = isSet(hwCap, hwcap_LRCPC)
	ARM64.HasDCPOP = isSet(hwCap, hwcap_DCPOP)
	ARM64.HasSHA3 = isSet(hwCap, hwcap_SHA3)
	ARM64.HasSM3 = isSet(hwCap, hwcap_SM3)
	ARM64.HasSM4 = isSet(hwCap, hwcap_SM4)
	ARM64.HasASIMDDP = isSet(hwCap, hwcap_ASIMDDP)
	ARM64.HasSHA512 = isSet(hwCap, hwcap_SHA512)
	ARM64.HasSVE = isSet(hwCap, hwcap_SVE)
	ARM64.HasASIMDFHM = isSet(hwCap, hwcap_ASIMDFHM)
	ARM64.HasDIT = isSet(hwCap, hwcap_DIT)

	// HWCAP2 feature bits
	ARM64.HasSVE2 = isSet(hwCap2, hwcap2_SVE2)
	ARM64.HasI8MM = isSet(hwCap2, hwcap2_I8MM)
}

func isSet(hwc uint, value uint) bool {
	return hwc&value != 0
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_netbsd_arm64.go
File Name: cpu_netbsd_arm64.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import (
	"syscall"
	"unsafe"
)

// Minimal copy of functionality from x/sys/unix so the cpu package can call
// sysctl without depending on x/sys/unix.

const (
	_CTL_QUERY = -2

	_SYSCTL_VERS_1 = 0x1000000
)

var _zero uintptr

func sysctl(mib []int32, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) {
	var _p0 unsafe.Pointer
	if len(mib) > 0 {
		_p0 = unsafe.Pointer(&mib[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, errno := syscall.Syscall6(
		syscall.SYS___SYSCTL,
		uintptr(_p0),
		uintptr(len(mib)),
		uintptr(unsafe.Pointer(old)),
		uintptr(unsafe.Pointer(oldlen)),
		uintptr(unsafe.Pointer(new)),
		uintptr(newlen))
	if errno != 0 {
		return errno
	}
	return nil
}

type sysctlNode struct {
	Flags          uint32
	Num            int32
	Name           [32]int8
	Ver            uint32
	__rsvd         uint32
	Un             [16]byte
	_sysctl_size   [8]byte
	_sysctl_func   [8]byte
	_sysctl_parent [8]byte
	_sysctl_desc   [8]byte
}

func sysctlNodes(mib []int32) ([]sysctlNode, error) {
	var olen uintptr

	// Get a list of all sysctl nodes below the given MIB by performing
	// a sysctl for the given MIB with CTL_QUERY appended.
	mib = append(mib, _CTL_QUERY)
	qnode := sysctlNode{Flags: _SYSCTL_VERS_1}
	qp := (*byte)(unsafe.Pointer(&qnode))
	sz := unsafe.Sizeof(qnode)
	if err := sysctl(mib, nil, &olen, qp, sz); err != nil {
		return nil, err
	}

	// Now that we know the size, get the actual nodes.
	nodes := make([]sysctlNode, olen/sz)
	np := (*byte)(unsafe.Pointer(&nodes[0]))
	if err := sysctl(mib, np, &olen, qp, sz); err != nil {
		return nil, err
	}

	return nodes, nil
}

func nametomib(name string) ([]int32, error) {
	// Split name into components.
	var parts []string
	last := 0
	for i := 0; i < len(name); i++ {
		if name[i] == '.' {
			parts = append(parts, name[last:i])
			last = i + 1
		}
	}
	parts = append(parts, name[last:])

	mib := []int32{}
	// Discover the nodes and construct the MIB OID.
	for partno, part := range parts {
		nodes, err := sysctlNodes(mib)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			n := make([]byte, 0)
			for i := range node.Name {
				if node.Name[i] != 0 {
					n = append(n, byte(node.Name[i]))
				}
			}
			if string(n) == part {
				mib = append(mib, int32(node.Num))
				break
			}
		}
		if len(mib) != partno+1 {
			return nil, err
		}
	}

	return mib, nil
}

// aarch64SysctlCPUID is struct aarch64_sysctl_cpu_id from NetBSD's <aarch64/armreg.h>
type aarch64SysctlCPUID struct {
	midr      uint64 /* Main ID Register */
	revidr    uint64 /* Revision ID Register */
	mpidr     uint64 /* Multiprocessor Affinity Register */
	aa64dfr0  uint64 /* A64 Debug Feature Register 0 */
	aa64dfr1  uint64 /* A64 Debug Feature Register 1 */
	aa64isar0 uint64 /* A64 Instruction Set Attribute Register 0 */
	aa64isar1 uint64 /* A64 Instruction Set Attribute Register 1 */
	aa64mmfr0 uint64 /* A64 Memory Model Feature Register 0 */
	aa64mmfr1 uint64 /* A64 Memory Model Feature Register 1 */
	aa64mmfr2 uint64 /* A64 Memory Model Feature Register 2 */
	aa64pfr0  uint64 /* A64 Processor Feature Register 0 */
	aa64pfr1  uint64 /* A64 Processor Feature Register 1 */
	aa64zfr0  uint64 /* A64 SVE Feature ID Register 0 */
	mvfr0     uint32 /* Media and VFP Feature Register 0 */
	mvfr1     uint32 /* Media and VFP Feature Register 1 */
	mvfr2     uint32 /* Media and VFP Feature Register 2 */
	pad       uint32
	clidr     uint64 /* Cache Level ID Register */
	ctr       uint64 /* Cache Type Register */
}

func sysctlCPUID(name string) (*aarch64SysctlCPUID, error) {
	mib, err := nametomib(name)
	if err != nil {
		return nil, err
	}

	out := aarch64SysctlCPUID{}
	n := unsafe.Sizeof(out)
	_, _, errno := syscall.Syscall6(
		syscall.SYS___SYSCTL,
		uintptr(unsafe.Pointer(&mib[0])),
		uintptr(len(mib)),
		uintptr(unsafe.Pointer(&out)),
		uintptr(unsafe.Pointer(&n)),
		uintptr(0),
		uintptr(0))
	if errno != 0 {
		return nil, errno
	}
	return &out, nil
}

func doinit() {
	cpuid, err := sysctlCPUID("machdep.cpu0.cpu_id")
	if err != nil {
		setMinimalFeatures()
		return
	}
	parseARM64SystemRegisters(cpuid.aa64isar0, cpuid.aa64isar1, cpuid.aa64pfr0)

	Initialized = true
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_linux_s390x.go
File Name: cpu_linux_s390x.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

const (
	// bit mask values from /usr/include/bits/hwcap.h
	hwcap_ZARCH  = 2
	hwcap_STFLE  = 4
	hwcap_MSA    = 8
	hwcap_LDISP  = 16
	hwcap_EIMM   = 32
	hwcap_DFP    = 64
	hwcap_ETF3EH = 256
	hwcap_VX     = 2048
	hwcap_VXE    = 8192
)

func initS390Xbase() {
	// test HWCAP bit vector
	has := func(featureMask uint) bool {
		return hwCap&featureMask == featureMask
	}

	// mandatory
	S390X.HasZARCH = has(hwcap_ZARCH)

	// optional
	S390X.HasSTFLE = has(hwcap_STFLE)
	S390X.HasLDISP = has(hwcap_LDISP)
	S390X.HasEIMM = has(hwcap_EIMM)
	S390X.HasETF3EH = has(hwcap_ETF3EH)
	S390X.HasDFP = has(hwcap_DFP)
	S390X.HasMSA = has(hwcap_MSA)
	S390X.HasVX = has(hwcap_VX)
	if S390X.HasVX {
		S390X.HasVXE = has(hwcap_VXE)
	}
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_other_arm64.go
File Name: cpu_other_arm64.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !linux && !netbsd && !openbsd && arm64

package cpu

func doinit() {}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_other_ppc64x.go
File Name: cpu_other_ppc64x.go

===========================================

// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !aix && !linux && (ppc64 || ppc64le)

package cpu

func archInit() {
	PPC64.IsPOWER8 = true
	Initialized = true
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_linux_ppc64x.go
File Name: cpu_linux_ppc64x.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && (ppc64 || ppc64le)

package cpu

// HWCAP/HWCAP2 bits. These are exposed by the kernel.
const (
	// ISA Level
	_PPC_FEATURE2_ARCH_2_07 = 0x80000000
	_PPC_FEATURE2_ARCH_3_00 = 0x00800000

	// CPU features
	_PPC_FEATURE2_DARN = 0x00200000
	_PPC_FEATURE2_SCV  = 0x00100000
)

func doinit() {
	// HWCAP2 feature bits
	PPC64.IsPOWER8 = isSet(hwCap2, _PPC_FEATURE2_ARCH_2_07)
	PPC64.IsPOWER9 = isSet(hwCap2, _PPC_FEATURE2_ARCH_3_00)
	PPC64.HasDARN = isSet(hwCap2, _PPC_FEATURE2_DARN)
	PPC64.HasSCV = isSet(hwCap2, _PPC_FEATURE2_SCV)
}

func isSet(hwc uint, value uint) bool {
	return hwc&value != 0
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/hwcap_linux.go
File Name: hwcap_linux.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import (
	"os"
)

const (
	_AT_HWCAP  = 16
	_AT_HWCAP2 = 26

	procAuxv = "/proc/self/auxv"

	uintSize = int(32 << (^uint(0) >> 63))
)

// For those platforms don't have a 'cpuid' equivalent we use HWCAP/HWCAP2
// These are initialized in cpu_$GOARCH.go
// and should not be changed after they are initialized.
var hwCap uint
var hwCap2 uint

func readHWCAP() error {
	// For Go 1.21+, get auxv from the Go runtime.
	if a := getAuxv(); len(a) > 0 {
		for len(a) >= 2 {
			tag, val := a[0], uint(a[1])
			a = a[2:]
			switch tag {
			case _AT_HWCAP:
				hwCap = val
			case _AT_HWCAP2:
				hwCap2 = val
			}
		}
		return nil
	}

	buf, err := os.ReadFile(procAuxv)
	if err != nil {
		// e.g. on android /proc/self/auxv is not accessible, so silently
		// ignore the error and leave Initialized = false. On some
		// architectures (e.g. arm64) doinit() implements a fallback
		// readout and will set Initialized = true again.
		return err
	}
	bo := hostByteOrder()
	for len(buf) >= 2*(uintSize/8) {
		var tag, val uint
		switch uintSize {
		case 32:
			tag = uint(bo.Uint32(buf[0:]))
			val = uint(bo.Uint32(buf[4:]))
			buf = buf[8:]
		case 64:
			tag = uint(bo.Uint64(buf[0:]))
			val = uint(bo.Uint64(buf[8:]))
			buf = buf[16:]
		}
		switch tag {
		case _AT_HWCAP:
			hwCap = val
		case _AT_HWCAP2:
			hwCap2 = val
		}
	}
	return nil
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_zos_s390x.go
File Name: cpu_zos_s390x.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

func initS390Xbase() {
	// get the facilities list
	facilities := stfle()

	// mandatory
	S390X.HasZARCH = facilities.Has(zarch)
	S390X.HasSTFLE = facilities.Has(stflef)
	S390X.HasLDISP = facilities.Has(ldisp)
	S390X.HasEIMM = facilities.Has(eimm)

	// optional
	S390X.HasETF3EH = facilities.Has(etf3eh)
	S390X.HasDFP = facilities.Has(dfp)
	S390X.HasMSA = facilities.Has(msa)
	S390X.HasVX = facilities.Has(vx)
	if S390X.HasVX {
		S390X.HasVXE = facilities.Has(vxe)
	}
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_linux_arm.go
File Name: cpu_linux_arm.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

func doinit() {
	ARM.HasSWP = isSet(hwCap, hwcap_SWP)
	ARM.HasHALF = isSet(hwCap, hwcap_HALF)
	ARM.HasTHUMB = isSet(hwCap, hwcap_THUMB)
	ARM.Has26BIT = isSet(hwCap, hwcap_26BIT)
	ARM.HasFASTMUL = isSet(hwCap, hwcap_FAST_MULT)
	ARM.HasFPA = isSet(hwCap, hwcap_FPA)
	ARM.HasVFP = isSet(hwCap, hwcap_VFP)
	ARM.HasEDSP = isSet(hwCap, hwcap_EDSP)
	ARM.HasJAVA = isSet(hwCap, hwcap_JAVA)
	ARM.HasIWMMXT = isSet(hwCap, hwcap_IWMMXT)
	ARM.HasCRUNCH = isSet(hwCap, hwcap_CRUNCH)
	ARM.HasTHUMBEE = isSet(hwCap, hwcap_THUMBEE)
	ARM.HasNEON = isSet(hwCap, hwcap_NEON)
	ARM.HasVFPv3 = isSet(hwCap, hwcap_VFPv3)
	ARM.HasVFPv3D16 = isSet(hwCap, hwcap_VFPv3D16)
	ARM.HasTLS = isSet(hwCap, hwcap_TLS)
	ARM.HasVFPv4 = isSet(hwCap, hwcap_VFPv4)
	ARM.HasIDIVA = isSet(hwCap, hwcap_IDIVA)
	ARM.HasIDIVT = isSet(hwCap, hwcap_IDIVT)
	ARM.HasVFPD32 = isSet(hwCap, hwcap_VFPD32)
	ARM.HasLPAE = isSet(hwCap, hwcap_LPAE)
	ARM.HasEVTSTRM = isSet(hwCap, hwcap_EVTSTRM)
	ARM.HasAES = isSet(hwCap2, hwcap2_AES)
	ARM.HasPMULL = isSet(hwCap2, hwcap2_PMULL)
	ARM.HasSHA1 = isSet(hwCap2, hwcap2_SHA1)
	ARM.HasSHA2 = isSet(hwCap2, hwcap2_SHA2)
	ARM.HasCRC32 = isSet(hwCap2, hwcap2_CRC32)
}

func isSet(hwc uint, value uint) bool {
	return hwc&value != 0
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_other_riscv64.go
File Name: cpu_other_riscv64.go

===========================================

// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !linux && riscv64

package cpu

func archInit() {
	Initialized = true
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_loong64.go
File Name: cpu_loong64.go

===========================================

// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build loong64

package cpu

const cacheLineSize = 64

func initOptions() {
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_linux.go
File Name: cpu_linux.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !386 && !amd64 && !amd64p32 && !arm64

package cpu

func archInit() {
	if err := readHWCAP(); err != nil {
		return
	}
	doinit()
	Initialized = true
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu.go
File Name: cpu.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package cpu implements processor feature detection for
// various CPU architectures.
package cpu

import (
	"os"
	"strings"
)

// Initialized reports whether the CPU features were initialized.
//
// For some GOOS/GOARCH combinations initialization of the CPU features depends
// on reading an operating specific file, e.g. /proc/self/auxv on linux/arm
// Initialized will report false if reading the file fails.
var Initialized bool

// CacheLinePad is used to pad structs to avoid false sharing.
type CacheLinePad struct{ _ [cacheLineSize]byte }

// X86 contains the supported CPU features of the
// current X86/AMD64 platform. If the current platform
// is not X86/AMD64 then all feature flags are false.
//
// X86 is padded to avoid false sharing. Further the HasAVX
// and HasAVX2 are only set if the OS supports XMM and YMM
// registers in addition to the CPUID feature bit being set.
var X86 struct {
	_                   CacheLinePad
	HasAES              bool // AES hardware implementation (AES NI)
	HasADX              bool // Multi-precision add-carry instruction extensions
	HasAVX              bool // Advanced vector extension
	HasAVX2             bool // Advanced vector extension 2
	HasAVX512           bool // Advanced vector extension 512
	HasAVX512F          bool // Advanced vector extension 512 Foundation Instructions
	HasAVX512CD         bool // Advanced vector extension 512 Conflict Detection Instructions
	HasAVX512ER         bool // Advanced vector extension 512 Exponential and Reciprocal Instructions
	HasAVX512PF         bool // Advanced vector extension 512 Prefetch Instructions
	HasAVX512VL         bool // Advanced vector extension 512 Vector Length Extensions
	HasAVX512BW         bool // Advanced vector extension 512 Byte and Word Instructions
	HasAVX512DQ         bool // Advanced vector extension 512 Doubleword and Quadword Instructions
	HasAVX512IFMA       bool // Advanced vector extension 512 Integer Fused Multiply Add
	HasAVX512VBMI       bool // Advanced vector extension 512 Vector Byte Manipulation Instructions
	HasAVX5124VNNIW     bool // Advanced vector extension 512 Vector Neural Network Instructions Word variable precision
	HasAVX5124FMAPS     bool // Advanced vector extension 512 Fused Multiply Accumulation Packed Single precision
	HasAVX512VPOPCNTDQ  bool // Advanced vector extension 512 Double and quad word population count instructions
	HasAVX512VPCLMULQDQ bool // Advanced vector extension 512 Vector carry-less multiply operations
	HasAVX512VNNI       bool // Advanced vector extension 512 Vector Neural Network Instructions
	HasAVX512GFNI       bool // Advanced vector extension 512 Galois field New Instructions
	HasAVX512VAES       bool // Advanced vector extension 512 Vector AES instructions
	HasAVX512VBMI2      bool // Advanced vector extension 512 Vector Byte Manipulation Instructions 2
	HasAVX512BITALG     bool // Advanced vector extension 512 Bit Algorithms
	HasAVX512BF16       bool // Advanced vector extension 512 BFloat16 Instructions
	HasAMXTile          bool // Advanced Matrix Extension Tile instructions
	HasAMXInt8          bool // Advanced Matrix Extension Int8 instructions
	HasAMXBF16          bool // Advanced Matrix Extension BFloat16 instructions
	HasBMI1             bool // Bit manipulation instruction set 1
	HasBMI2             bool // Bit manipulation instruction set 2
	HasCX16             bool // Compare and exchange 16 Bytes
	HasERMS             bool // Enhanced REP for MOVSB and STOSB
	HasFMA              bool // Fused-multiply-add instructions
	HasOSXSAVE          bool // OS supports XSAVE/XRESTOR for saving/restoring XMM registers.
	HasPCLMULQDQ        bool // PCLMULQDQ instruction - most often used for AES-GCM
	HasPOPCNT           bool // Hamming weight instruction POPCNT.
	HasRDRAND           bool // RDRAND instruction (on-chip random number generator)
	HasRDSEED           bool // RDSEED instruction (on-chip random number generator)
	HasSSE2             bool // Streaming SIMD extension 2 (always available on amd64)
	HasSSE3             bool // Streaming SIMD extension 3
	HasSSSE3            bool // Supplemental streaming SIMD extension 3
	HasSSE41            bool // Streaming SIMD extension 4 and 4.1
	HasSSE42            bool // Streaming SIMD extension 4 and 4.2
	_                   CacheLinePad
}

// ARM64 contains the supported CPU features of the
// current ARMv8(aarch64) platform. If the current platform
// is not arm64 then all feature flags are false.
var ARM64 struct {
	_           CacheLinePad
	HasFP       bool // Floating-point instruction set (always available)
	HasASIMD    bool // Advanced SIMD (always available)
	HasEVTSTRM  bool // Event stream support
	HasAES      bool // AES hardware implementation
	HasPMULL    bool // Polynomial multiplication instruction set
	HasSHA1     bool // SHA1 hardware implementation
	HasSHA2     bool // SHA2 hardware implementation
	HasCRC32    bool // CRC32 hardware implementation
	HasATOMICS  bool // Atomic memory operation instruction set
	HasFPHP     bool // Half precision floating-point instruction set
	HasASIMDHP  bool // Advanced SIMD half precision instruction set
	HasCPUID    bool // CPUID identification scheme registers
	HasASIMDRDM bool // Rounding double multiply add/subtract instruction set
	HasJSCVT    bool // Javascript conversion from floating-point to integer
	HasFCMA     bool // Floating-point multiplication and addition of complex numbers
	HasLRCPC    bool // Release Consistent processor consistent support
	HasDCPOP    bool // Persistent memory support
	HasSHA3     bool // SHA3 hardware implementation
	HasSM3      bool // SM3 hardware implementation
	HasSM4      bool // SM4 hardware implementation
	HasASIMDDP  bool // Advanced SIMD double precision instruction set
	HasSHA512   bool // SHA512 hardware implementation
	HasSVE      bool // Scalable Vector Extensions
	HasSVE2     bool // Scalable Vector Extensions 2
	HasASIMDFHM bool // Advanced SIMD multiplication FP16 to FP32
	HasDIT      bool // Data Independent Timing support
	HasI8MM     bool // Advanced SIMD Int8 matrix multiplication instructions
	_           CacheLinePad
}

// ARM contains the supported CPU features of the current ARM (32-bit) platform.
// All feature flags are false if:
//  1. the current platform is not arm, or
//  2. the current operating system is not Linux.
var ARM struct {
	_           CacheLinePad
	HasSWP      bool // SWP instruction support
	HasHALF     bool // Half-word load and store support
	HasTHUMB    bool // ARM Thumb instruction set
	Has26BIT    bool // Address space limited to 26-bits
	HasFASTMUL  bool // 32-bit operand, 64-bit result multiplication support
	HasFPA      bool // Floating point arithmetic support
	HasVFP      bool // Vector floating point support
	HasEDSP     bool // DSP Extensions support
	HasJAVA     bool // Java instruction set
	HasIWMMXT   bool // Intel Wireless MMX technology support
	HasCRUNCH   bool // MaverickCrunch context switching and handling
	HasTHUMBEE  bool // Thumb EE instruction set
	HasNEON     bool // NEON instruction set
	HasVFPv3    bool // Vector floating point version 3 support
	HasVFPv3D16 bool // Vector floating point version 3 D8-D15
	HasTLS      bool // Thread local storage support
	HasVFPv4    bool // Vector floating point version 4 support
	HasIDIVA    bool // Integer divide instruction support in ARM mode
	HasIDIVT    bool // Integer divide instruction support in Thumb mode
	HasVFPD32   bool // Vector floating point version 3 D15-D31
	HasLPAE     bool // Large Physical Address Extensions
	HasEVTSTRM  bool // Event stream support
	HasAES      bool // AES hardware implementation
	HasPMULL    bool // Polynomial multiplication instruction set
	HasSHA1     bool // SHA1 hardware implementation
	HasSHA2     bool // SHA2 hardware implementation
	HasCRC32    bool // CRC32 hardware implementation
	_           CacheLinePad
}

// MIPS64X contains the supported CPU features of the current mips64/mips64le
// platforms. If the current platform is not mips64/mips64le or the current
// operating system is not Linux then all feature flags are false.
var MIPS64X struct {
	_      CacheLinePad
	HasMSA bool // MIPS SIMD architecture
	_      CacheLinePad
}

// PPC64 contains the supported CPU features of the current ppc64/ppc64le platforms.
// If the current platform is not ppc64/ppc64le then all feature flags are false.
//
// For ppc64/ppc64le, it is safe to check only for ISA level starting on ISA v3.00,
// since there are no optional categories. There are some exceptions that also
// require kernel support to work (DARN, SCV), so there are feature bits for
// those as well. The struct is padded to avoid false sharing.
var PPC64 struct {
	_        CacheLinePad
	HasDARN  bool // Hardware random number generator (requires kernel enablement)
	HasSCV   bool // Syscall vectored (requires kernel enablement)
	IsPOWER8 bool // ISA v2.07 (POWER8)
	IsPOWER9 bool // ISA v3.00 (POWER9), implies IsPOWER8
	_        CacheLinePad
}

// S390X contains the supported CPU features of the current IBM Z
// (s390x) platform. If the current platform is not IBM Z then all
// feature flags are false.
//
// S390X is padded to avoid false sharing. Further HasVX is only set
// if the OS supports vector registers in addition to the STFLE
// feature bit being set.
var S390X struct {
	_         CacheLinePad
	HasZARCH  bool // z/Architecture mode is active [mandatory]
	HasSTFLE  bool // store facility list extended
	HasLDISP  bool // long (20-bit) displacements
	HasEIMM   bool // 32-bit immediates
	HasDFP    bool // decimal floating point
	HasETF3EH bool // ETF-3 enhanced
	HasMSA    bool // message security assist (CPACF)
	HasAES    bool // KM-AES{128,192,256} functions
	HasAESCBC bool // KMC-AES{128,192,256} functions
	HasAESCTR bool // KMCTR-AES{128,192,256} functions
	HasAESGCM bool // KMA-GCM-AES{128,192,256} functions
	HasGHASH  bool // KIMD-GHASH function
	HasSHA1   bool // K{I,L}MD-SHA-1 functions
	HasSHA256 bool // K{I,L}MD-SHA-256 functions
	HasSHA512 bool // K{I,L}MD-SHA-512 functions
	HasSHA3   bool // K{I,L}MD-SHA3-{224,256,384,512} and K{I,L}MD-SHAKE-{128,256} functions
	HasVX     bool // vector facility
	HasVXE    bool // vector-enhancements facility 1
	_         CacheLinePad
}

// RISCV64 contains the supported CPU features and performance characteristics for riscv64
// platforms. The booleans in RISCV64, with the exception of HasFastMisaligned, indicate
// the presence of RISC-V extensions.
//
// It is safe to assume that all the RV64G extensions are supported and so they are omitted from
// this structure. As riscv64 Go programs require at least RV64G, the code that populates
// this structure cannot run successfully if some of the RV64G extensions are missing.
// The struct is padded to avoid false sharing.
var RISCV64 struct {
	_                 CacheLinePad
	HasFastMisaligned bool // Fast misaligned accesses
	HasC              bool // Compressed instruction-set extension
	HasV              bool // Vector extension compatible with RVV 1.0
	HasZba            bool // Address generation instructions extension
	HasZbb            bool // Basic bit-manipulation extension
	HasZbs            bool // Single-bit instructions extension
	_                 CacheLinePad
}

func init() {
	archInit()
	initOptions()
	processOptions()
}

// options contains the cpu debug options that can be used in GODEBUG.
// Options are arch dependent and are added by the arch specific initOptions functions.
// Features that are mandatory for the specific GOARCH should have the Required field set
// (e.g. SSE2 on amd64).
var options []option

// Option names should be lower case. e.g. avx instead of AVX.
type option struct {
	Name      string
	Feature   *bool
	Specified bool // whether feature value was specified in GODEBUG
	Enable    bool // whether feature should be enabled
	Required  bool // whether feature is mandatory and can not be disabled
}

func processOptions() {
	env := os.Getenv("GODEBUG")
field:
	for env != "" {
		field := ""
		i := strings.IndexByte(env, ',')
		if i < 0 {
			field, env = env, ""
		} else {
			field, env = env[:i], env[i+1:]
		}
		if len(field) < 4 || field[:4] != "cpu." {
			continue
		}
		i = strings.IndexByte(field, '=')
		if i < 0 {
			print("GODEBUG sys/cpu: no value specified for \"", field, "\"\n")
			continue
		}
		key, value := field[4:i], field[i+1:] // e.g. "SSE2", "on"

		var enable bool
		switch value {
		case "on":
			enable = true
		case "off":
			enable = false
		default:
			print("GODEBUG sys/cpu: value \"", value, "\" not supported for cpu option \"", key, "\"\n")
			continue field
		}

		if key == "all" {
			for i := range options {
				options[i].Specified = true
				options[i].Enable = enable || options[i].Required
			}
			continue field
		}

		for i := range options {
			if options[i].Name == key {
				options[i].Specified = true
				options[i].Enable = enable
				continue field
			}
		}

		print("GODEBUG sys/cpu: unknown cpu feature \"", key, "\"\n")
	}

	for _, o := range options {
		if !o.Specified {
			continue
		}

		if o.Enable && !*o.Feature {
			print("GODEBUG sys/cpu: can not enable \"", o.Name, "\", missing CPU support\n")
			continue
		}

		if !o.Enable && o.Required {
			print("GODEBUG sys/cpu: can not disable \"", o.Name, "\", required CPU feature\n")
			continue
		}

		*o.Feature = o.Enable
	}
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_zos.go
File Name: cpu_zos.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

func archInit() {
	doinit()
	Initialized = true
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_ppc64x.go
File Name: cpu_ppc64x.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ppc64 || ppc64le

package cpu

const cacheLineSize = 128

func initOptions() {
	options = []option{
		{Name: "darn", Feature: &PPC64.HasDARN},
		{Name: "scv", Feature: &PPC64.HasSCV},
	}
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_other_mips64x.go
File Name: cpu_other_mips64x.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !linux && (mips64 || mips64le)

package cpu

func archInit() {
	Initialized = true
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_gc_x86.go
File Name: cpu_gc_x86.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build (386 || amd64 || amd64p32) && gc

package cpu

// cpuid is implemented in cpu_gc_x86.s for gc compiler
// and in cpu_gccgo.c for gccgo.
func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)

// xgetbv with ecx = 0 is implemented in cpu_gc_x86.s for gc compiler
// and in cpu_gccgo.c for gccgo.
func xgetbv() (eax, edx uint32)

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/endian_big.go
File Name: endian_big.go

===========================================

// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build armbe || arm64be || m68k || mips || mips64 || mips64p32 || ppc || ppc64 || s390 || s390x || shbe || sparc || sparc64

package cpu

// IsBigEndian records whether the GOARCH's byte order is big endian.
const IsBigEndian = true

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_darwin_x86.go
File Name: cpu_darwin_x86.go

===========================================

// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build darwin && amd64 && gc

package cpu

// darwinSupportsAVX512 checks Darwin kernel for AVX512 support via sysctl
// call (see issue 43089). It also restricts AVX512 support for Darwin to
// kernel version 21.3.0 (MacOS 12.2.0) or later (see issue 49233).
//
// Background:
// Darwin implements a special mechanism to economize on thread state when
// AVX512 specific registers are not in use. This scheme minimizes state when
// preempting threads that haven't yet used any AVX512 instructions, but adds
// special requirements to check for AVX512 hardware support at runtime (e.g.
// via sysctl call or commpage inspection). See issue 43089 and link below for
// full background:
// https://github.com/apple-oss-distributions/xnu/blob/xnu-11215.1.10/osfmk/i386/fpu.c#L214-L240
//
// Additionally, all versions of the Darwin kernel from 19.6.0 through 21.2.0
// (corresponding to MacOS 10.15.6 - 12.1) have a bug that can cause corruption
// of the AVX512 mask registers (K0-K7) upon signal return. For this reason
// AVX512 is considered unsafe to use on Darwin for kernel versions prior to
// 21.3.0, where a fix has been confirmed. See issue 49233 for full background.
func darwinSupportsAVX512() bool {
	return darwinSysctlEnabled([]byte("hw.optional.avx512f\x00")) && darwinKernelVersionCheck(21, 3, 0)
}

// Ensure Darwin kernel version is at least major.minor.patch, avoiding dependencies
func darwinKernelVersionCheck(major, minor, patch int) bool {
	var release [256]byte
	err := darwinOSRelease(&release)
	if err != nil {
		return false
	}

	var mmp [3]int
	c := 0
Loop:
	for _, b := range release[:] {
		switch {
		case b >= '0' && b <= '9':
			mmp[c] = 10*mmp[c] + int(b-'0')
		case b == '.':
			c++
			if c > 2 {
				return false
			}
		case b == 0:
			break Loop
		default:
			return false
		}
	}
	if c != 2 {
		return false
	}
	return mmp[0] > major || mmp[0] == major && (mmp[1] > minor || mmp[1] == minor && mmp[2] >= patch)
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_riscv64.go
File Name: cpu_riscv64.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build riscv64

package cpu

const cacheLineSize = 64

func initOptions() {
	options = []option{
		{Name: "fastmisaligned", Feature: &RISCV64.HasFastMisaligned},
		{Name: "c", Feature: &RISCV64.HasC},
		{Name: "v", Feature: &RISCV64.HasV},
		{Name: "zba", Feature: &RISCV64.HasZba},
		{Name: "zbb", Feature: &RISCV64.HasZbb},
		{Name: "zbs", Feature: &RISCV64.HasZbs},
	}
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/byteorder.go
File Name: byteorder.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import (
	"runtime"
)

// byteOrder is a subset of encoding/binary.ByteOrder.
type byteOrder interface {
	Uint32([]byte) uint32
	Uint64([]byte) uint64
}

type littleEndian struct{}
type bigEndian struct{}

func (littleEndian) Uint32(b []byte) uint32 {
	_ = b[3] // bounds check hint to compiler; see golang.org/issue/14808
	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
}

func (littleEndian) Uint64(b []byte) uint64 {
	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808
	return uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |
		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
}

func (bigEndian) Uint32(b []byte) uint32 {
	_ = b[3] // bounds check hint to compiler; see golang.org/issue/14808
	return uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
}

func (bigEndian) Uint64(b []byte) uint64 {
	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808
	return uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
}

// hostByteOrder returns littleEndian on little-endian machines and
// bigEndian on big-endian machines.
func hostByteOrder() byteOrder {
	switch runtime.GOARCH {
	case "386", "amd64", "amd64p32",
		"alpha",
		"arm", "arm64",
		"loong64",
		"mipsle", "mips64le", "mips64p32le",
		"nios2",
		"ppc64le",
		"riscv", "riscv64",
		"sh":
		return littleEndian{}
	case "armbe", "arm64be",
		"m68k",
		"mips", "mips64", "mips64p32",
		"ppc", "ppc64",
		"s390", "s390x",
		"shbe",
		"sparc", "sparc64":
		return bigEndian{}
	}
	panic("unknown architecture")
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/runtime_auxv.go
File Name: runtime_auxv.go

===========================================

// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

// getAuxvFn is non-nil on Go 1.21+ (via runtime_auxv_go121.go init)
// on platforms that use auxv.
var getAuxvFn func() []uintptr

func getAuxv() []uintptr {
	if getAuxvFn == nil {
		return nil
	}
	return getAuxvFn()
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_mipsx.go
File Name: cpu_mipsx.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build mips || mipsle

package cpu

const cacheLineSize = 32

func initOptions() {}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_wasm.go
File Name: cpu_wasm.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build wasm

package cpu

// We're compiling the cpu package for an unknown (software-abstracted) CPU.
// Make CacheLinePad an empty struct and hope that the usual struct alignment
// rules are good enough.

const cacheLineSize = 0

func initOptions() {}

func archInit() {}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_linux_mips64x.go
File Name: cpu_linux_mips64x.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && (mips64 || mips64le)

package cpu

// HWCAP bits. These are exposed by the Linux kernel 5.4.
const (
	// CPU features
	hwcap_MIPS_MSA = 1 << 1
)

func doinit() {
	// HWCAP feature bits
	MIPS64X.HasMSA = isSet(hwCap, hwcap_MIPS_MSA)
}

func isSet(hwc uint, value uint) bool {
	return hwc&value != 0
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_other_arm.go
File Name: cpu_other_arm.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !linux && arm

package cpu

func archInit() {}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_arm.go
File Name: cpu_arm.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

const cacheLineSize = 32

// HWCAP/HWCAP2 bits.
// These are specific to Linux.
const (
	hwcap_SWP       = 1 << 0
	hwcap_HALF      = 1 << 1
	hwcap_THUMB     = 1 << 2
	hwcap_26BIT     = 1 << 3
	hwcap_FAST_MULT = 1 << 4
	hwcap_FPA       = 1 << 5
	hwcap_VFP       = 1 << 6
	hwcap_EDSP      = 1 << 7
	hwcap_JAVA      = 1 << 8
	hwcap_IWMMXT    = 1 << 9
	hwcap_CRUNCH    = 1 << 10
	hwcap_THUMBEE   = 1 << 11
	hwcap_NEON      = 1 << 12
	hwcap_VFPv3     = 1 << 13
	hwcap_VFPv3D16  = 1 << 14
	hwcap_TLS       = 1 << 15
	hwcap_VFPv4     = 1 << 16
	hwcap_IDIVA     = 1 << 17
	hwcap_IDIVT     = 1 << 18
	hwcap_VFPD32    = 1 << 19
	hwcap_LPAE      = 1 << 20
	hwcap_EVTSTRM   = 1 << 21

	hwcap2_AES   = 1 << 0
	hwcap2_PMULL = 1 << 1
	hwcap2_SHA1  = 1 << 2
	hwcap2_SHA2  = 1 << 3
	hwcap2_CRC32 = 1 << 4
)

func initOptions() {
	options = []option{
		{Name: "pmull", Feature: &ARM.HasPMULL},
		{Name: "sha1", Feature: &ARM.HasSHA1},
		{Name: "sha2", Feature: &ARM.HasSHA2},
		{Name: "swp", Feature: &ARM.HasSWP},
		{Name: "thumb", Feature: &ARM.HasTHUMB},
		{Name: "thumbee", Feature: &ARM.HasTHUMBEE},
		{Name: "tls", Feature: &ARM.HasTLS},
		{Name: "vfp", Feature: &ARM.HasVFP},
		{Name: "vfpd32", Feature: &ARM.HasVFPD32},
		{Name: "vfpv3", Feature: &ARM.HasVFPv3},
		{Name: "vfpv3d16", Feature: &ARM.HasVFPv3D16},
		{Name: "vfpv4", Feature: &ARM.HasVFPv4},
		{Name: "half", Feature: &ARM.HasHALF},
		{Name: "26bit", Feature: &ARM.Has26BIT},
		{Name: "fastmul", Feature: &ARM.HasFASTMUL},
		{Name: "fpa", Feature: &ARM.HasFPA},
		{Name: "edsp", Feature: &ARM.HasEDSP},
		{Name: "java", Feature: &ARM.HasJAVA},
		{Name: "iwmmxt", Feature: &ARM.HasIWMMXT},
		{Name: "crunch", Feature: &ARM.HasCRUNCH},
		{Name: "neon", Feature: &ARM.HasNEON},
		{Name: "idivt", Feature: &ARM.HasIDIVT},
		{Name: "idiva", Feature: &ARM.HasIDIVA},
		{Name: "lpae", Feature: &ARM.HasLPAE},
		{Name: "evtstrm", Feature: &ARM.HasEVTSTRM},
		{Name: "aes", Feature: &ARM.HasAES},
		{Name: "crc32", Feature: &ARM.HasCRC32},
	}

}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_linux_riscv64.go
File Name: cpu_linux_riscv64.go

===========================================

// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import (
	"syscall"
	"unsafe"
)

// RISC-V extension discovery code for Linux. The approach here is to first try the riscv_hwprobe
// syscall falling back to HWCAP to check for the C extension if riscv_hwprobe is not available.
//
// A note on detection of the Vector extension using HWCAP.
//
// Support for the Vector extension version 1.0 was added to the Linux kernel in release 6.5.
// Support for the riscv_hwprobe syscall was added in 6.4. It follows that if the riscv_hwprobe
// syscall is not available then neither is the Vector extension (which needs kernel support).
// The riscv_hwprobe syscall should then be all we need to detect the Vector extension.
// However, some RISC-V board manufacturers ship boards with an older kernel on top of which
// they have back-ported various versions of the Vector extension patches but not the riscv_hwprobe
// patches. These kernels advertise support for the Vector extension using HWCAP. Falling
// back to HWCAP to detect the Vector extension, if riscv_hwprobe is not available, or simply not
// bothering with riscv_hwprobe at all and just using HWCAP may then seem like an attractive option.
//
// Unfortunately, simply checking the 'V' bit in AT_HWCAP will not work as this bit is used by
// RISC-V board and cloud instance providers to mean different things. The Lichee Pi 4A board
// and the Scaleway RV1 cloud instances use the 'V' bit to advertise their support for the unratified
// 0.7.1 version of the Vector Specification. The Banana Pi BPI-F3 and the CanMV-K230 board use
// it to advertise support for 1.0 of the Vector extension. Versions 0.7.1 and 1.0 of the Vector
// extension are binary incompatible. HWCAP can then not be used in isolation to populate the
// HasV field as this field indicates that the underlying CPU is compatible with RVV 1.0.
//
// There is a way at runtime to distinguish between versions 0.7.1 and 1.0 of the Vector
// specification by issuing a RVV 1.0 vsetvli instruction and checking the vill bit of the vtype
// register. This check would allow us to safely detect version 1.0 of the Vector extension
// with HWCAP, if riscv_hwprobe were not available. However, the check cannot
// be added until the assembler supports the Vector instructions.
//
// Note the riscv_hwprobe syscall does not suffer from these ambiguities by design as all of the
// extensions it advertises support for are explicitly versioned. It's also worth noting that
// the riscv_hwprobe syscall is the only way to detect multi-letter RISC-V extensions, e.g., Zba.
// These cannot be detected using HWCAP and so riscv_hwprobe must be used to detect the majority
// of RISC-V extensions.
//
// Please see https://docs.kernel.org/arch/riscv/hwprobe.html for more information.

// golang.org/x/sys/cpu is not allowed to depend on golang.org/x/sys/unix so we must
// reproduce the constants, types and functions needed to make the riscv_hwprobe syscall
// here.

const (
	// Copied from golang.org/x/sys/unix/ztypes_linux_riscv64.go.
	riscv_HWPROBE_KEY_IMA_EXT_0   = 0x4
	riscv_HWPROBE_IMA_C           = 0x2
	riscv_HWPROBE_IMA_V           = 0x4
	riscv_HWPROBE_EXT_ZBA         = 0x8
	riscv_HWPROBE_EXT_ZBB         = 0x10
	riscv_HWPROBE_EXT_ZBS         = 0x20
	riscv_HWPROBE_KEY_CPUPERF_0   = 0x5
	riscv_HWPROBE_MISALIGNED_FAST = 0x3
	riscv_HWPROBE_MISALIGNED_MASK = 0x7
)

const (
	// sys_RISCV_HWPROBE is copied from golang.org/x/sys/unix/zsysnum_linux_riscv64.go.
	sys_RISCV_HWPROBE = 258
)

// riscvHWProbePairs is copied from golang.org/x/sys/unix/ztypes_linux_riscv64.go.
type riscvHWProbePairs struct {
	key   int64
	value uint64
}

const (
	// CPU features
	hwcap_RISCV_ISA_C = 1 << ('C' - 'A')
)

func doinit() {
	// A slice of key/value pair structures is passed to the RISCVHWProbe syscall. The key
	// field should be initialised with one of the key constants defined above, e.g.,
	// RISCV_HWPROBE_KEY_IMA_EXT_0. The syscall will set the value field to the appropriate value.
	// If the kernel does not recognise a key it will set the key field to -1 and the value field to 0.

	pairs := []riscvHWProbePairs{
		{riscv_HWPROBE_KEY_IMA_EXT_0, 0},
		{riscv_HWPROBE_KEY_CPUPERF_0, 0},
	}

	// This call only indicates that extensions are supported if they are implemented on all cores.
	if riscvHWProbe(pairs, 0) {
		if pairs[0].key != -1 {
			v := uint(pairs[0].value)
			RISCV64.HasC = isSet(v, riscv_HWPROBE_IMA_C)
			RISCV64.HasV = isSet(v, riscv_HWPROBE_IMA_V)
			RISCV64.HasZba = isSet(v, riscv_HWPROBE_EXT_ZBA)
			RISCV64.HasZbb = isSet(v, riscv_HWPROBE_EXT_ZBB)
			RISCV64.HasZbs = isSet(v, riscv_HWPROBE_EXT_ZBS)
		}
		if pairs[1].key != -1 {
			v := pairs[1].value & riscv_HWPROBE_MISALIGNED_MASK
			RISCV64.HasFastMisaligned = v == riscv_HWPROBE_MISALIGNED_FAST
		}
	}

	// Let's double check with HWCAP if the C extension does not appear to be supported.
	// This may happen if we're running on a kernel older than 6.4.

	if !RISCV64.HasC {
		RISCV64.HasC = isSet(hwCap, hwcap_RISCV_ISA_C)
	}
}

func isSet(hwc uint, value uint) bool {
	return hwc&value != 0
}

// riscvHWProbe is a simplified version of the generated wrapper function found in
// golang.org/x/sys/unix/zsyscall_linux_riscv64.go. We simplify it by removing the
// cpuCount and cpus parameters which we do not need. We always want to pass 0 for
// these parameters here so the kernel only reports the extensions that are present
// on all cores.
func riscvHWProbe(pairs []riscvHWProbePairs, flags uint) bool {
	var _zero uintptr
	var p0 unsafe.Pointer
	if len(pairs) > 0 {
		p0 = unsafe.Pointer(&pairs[0])
	} else {
		p0 = unsafe.Pointer(&_zero)
	}

	_, _, e1 := syscall.Syscall6(sys_RISCV_HWPROBE, uintptr(p0), uintptr(len(pairs)), uintptr(0), uintptr(0), uintptr(flags), 0)
	return e1 == 0
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_gc_s390x.go
File Name: cpu_gc_s390x.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build gc

package cpu

// haveAsmFunctions reports whether the other functions in this file can
// be safely called.
func haveAsmFunctions() bool { return true }

// The following feature detection functions are defined in cpu_s390x.s.
// They are likely to be expensive to call so the results should be cached.
func stfle() facilityList
func kmQuery() queryResult
func kmcQuery() queryResult
func kmctrQuery() queryResult
func kmaQuery() queryResult
func kimdQuery() queryResult
func klmdQuery() queryResult

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_gc_arm64.go
File Name: cpu_gc_arm64.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build gc

package cpu

func getisar0() uint64
func getisar1() uint64
func getpfr0() uint64
func getzfr0() uint64

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_mips64x.go
File Name: cpu_mips64x.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build mips64 || mips64le

package cpu

const cacheLineSize = 32

func initOptions() {
	options = []option{
		{Name: "msa", Feature: &MIPS64X.HasMSA},
	}
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/syscall_darwin_x86_gc.go
File Name: syscall_darwin_x86_gc.go

===========================================

// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Minimal copy of x/sys/unix so the cpu package can make a
// system call on Darwin without depending on x/sys/unix.

//go:build darwin && amd64 && gc

package cpu

import (
	"syscall"
	"unsafe"
)

type _C_int int32

// adapted from unix.Uname() at x/sys/unix/syscall_darwin.go L419
func darwinOSRelease(release *[256]byte) error {
	// from x/sys/unix/zerrors_openbsd_amd64.go
	const (
		CTL_KERN       = 0x1
		KERN_OSRELEASE = 0x2
	)

	mib := []_C_int{CTL_KERN, KERN_OSRELEASE}
	n := unsafe.Sizeof(*release)

	return sysctl(mib, &release[0], &n, nil, 0)
}

type Errno = syscall.Errno

var _zero uintptr // Single-word zero for use when we need a valid pointer to 0 bytes.

// from x/sys/unix/zsyscall_darwin_amd64.go L791-807
func sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) error {
	var _p0 unsafe.Pointer
	if len(mib) > 0 {
		_p0 = unsafe.Pointer(&mib[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	if _, _, err := syscall_syscall6(
		libc_sysctl_trampoline_addr,
		uintptr(_p0),
		uintptr(len(mib)),
		uintptr(unsafe.Pointer(old)),
		uintptr(unsafe.Pointer(oldlen)),
		uintptr(unsafe.Pointer(new)),
		uintptr(newlen),
	); err != 0 {
		return err
	}

	return nil
}

var libc_sysctl_trampoline_addr uintptr

// adapted from internal/cpu/cpu_arm64_darwin.go
func darwinSysctlEnabled(name []byte) bool {
	out := int32(0)
	nout := unsafe.Sizeof(out)
	if ret := sysctlbyname(&name[0], (*byte)(unsafe.Pointer(&out)), &nout, nil, 0); ret != nil {
		return false
	}
	return out > 0
}

//go:cgo_import_dynamic libc_sysctl sysctl "/usr/lib/libSystem.B.dylib"

var libc_sysctlbyname_trampoline_addr uintptr

// adapted from runtime/sys_darwin.go in the pattern of sysctl() above, as defined in x/sys/unix
func sysctlbyname(name *byte, old *byte, oldlen *uintptr, new *byte, newlen uintptr) error {
	if _, _, err := syscall_syscall6(
		libc_sysctlbyname_trampoline_addr,
		uintptr(unsafe.Pointer(name)),
		uintptr(unsafe.Pointer(old)),
		uintptr(unsafe.Pointer(oldlen)),
		uintptr(unsafe.Pointer(new)),
		uintptr(newlen),
		0,
	); err != 0 {
		return err
	}

	return nil
}

//go:cgo_import_dynamic libc_sysctlbyname sysctlbyname "/usr/lib/libSystem.B.dylib"

// Implemented in the runtime package (runtime/sys_darwin.go)
func syscall_syscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)

//go:linkname syscall_syscall6 syscall.syscall6

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/syscall_aix_gccgo.go
File Name: syscall_aix_gccgo.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Recreate a getsystemcfg syscall handler instead of
// using the one provided by x/sys/unix to avoid having
// the dependency between them. (See golang.org/issue/32102)
// Moreover, this file will be used during the building of
// gccgo's libgo and thus must not used a CGo method.

//go:build aix && gccgo

package cpu

import (
	"syscall"
)

//extern getsystemcfg
func gccgoGetsystemcfg(label uint32) (r uint64)

func callgetsystemcfg(label int) (r1 uintptr, e1 syscall.Errno) {
	r1 = uintptr(gccgoGetsystemcfg(uint32(label)))
	e1 = syscall.GetErrno()
	return
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/runtime_auxv_go121.go
File Name: runtime_auxv_go121.go

===========================================

// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build go1.21

package cpu

import (
	_ "unsafe" // for linkname
)

//go:linkname runtime_getAuxv runtime.getAuxv
func runtime_getAuxv() []uintptr

func init() {
	getAuxvFn = runtime_getAuxv
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_arm64.go
File Name: cpu_arm64.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import "runtime"

// cacheLineSize is used to prevent false sharing of cache lines.
// We choose 128 because Apple Silicon, a.k.a. M1, has 128-byte cache line size.
// It doesn't cost much and is much more future-proof.
const cacheLineSize = 128

func initOptions() {
	options = []option{
		{Name: "fp", Feature: &ARM64.HasFP},
		{Name: "asimd", Feature: &ARM64.HasASIMD},
		{Name: "evstrm", Feature: &ARM64.HasEVTSTRM},
		{Name: "aes", Feature: &ARM64.HasAES},
		{Name: "fphp", Feature: &ARM64.HasFPHP},
		{Name: "jscvt", Feature: &ARM64.HasJSCVT},
		{Name: "lrcpc", Feature: &ARM64.HasLRCPC},
		{Name: "pmull", Feature: &ARM64.HasPMULL},
		{Name: "sha1", Feature: &ARM64.HasSHA1},
		{Name: "sha2", Feature: &ARM64.HasSHA2},
		{Name: "sha3", Feature: &ARM64.HasSHA3},
		{Name: "sha512", Feature: &ARM64.HasSHA512},
		{Name: "sm3", Feature: &ARM64.HasSM3},
		{Name: "sm4", Feature: &ARM64.HasSM4},
		{Name: "sve", Feature: &ARM64.HasSVE},
		{Name: "sve2", Feature: &ARM64.HasSVE2},
		{Name: "crc32", Feature: &ARM64.HasCRC32},
		{Name: "atomics", Feature: &ARM64.HasATOMICS},
		{Name: "asimdhp", Feature: &ARM64.HasASIMDHP},
		{Name: "cpuid", Feature: &ARM64.HasCPUID},
		{Name: "asimrdm", Feature: &ARM64.HasASIMDRDM},
		{Name: "fcma", Feature: &ARM64.HasFCMA},
		{Name: "dcpop", Feature: &ARM64.HasDCPOP},
		{Name: "asimddp", Feature: &ARM64.HasASIMDDP},
		{Name: "asimdfhm", Feature: &ARM64.HasASIMDFHM},
		{Name: "dit", Feature: &ARM64.HasDIT},
		{Name: "i8mm", Feature: &ARM64.HasI8MM},
	}
}

func archInit() {
	switch runtime.GOOS {
	case "freebsd":
		readARM64Registers()
	case "linux", "netbsd", "openbsd":
		doinit()
	default:
		// Many platforms don't seem to allow reading these registers.
		setMinimalFeatures()
	}
}

// setMinimalFeatures fakes the minimal ARM64 features expected by
// TestARM64minimalFeatures.
func setMinimalFeatures() {
	ARM64.HasASIMD = true
	ARM64.HasFP = true
}

func readARM64Registers() {
	Initialized = true

	parseARM64SystemRegisters(getisar0(), getisar1(), getpfr0())
}

func parseARM64SystemRegisters(isar0, isar1, pfr0 uint64) {
	// ID_AA64ISAR0_EL1
	switch extractBits(isar0, 4, 7) {
	case 1:
		ARM64.HasAES = true
	case 2:
		ARM64.HasAES = true
		ARM64.HasPMULL = true
	}

	switch extractBits(isar0, 8, 11) {
	case 1:
		ARM64.HasSHA1 = true
	}

	switch extractBits(isar0, 12, 15) {
	case 1:
		ARM64.HasSHA2 = true
	case 2:
		ARM64.HasSHA2 = true
		ARM64.HasSHA512 = true
	}

	switch extractBits(isar0, 16, 19) {
	case 1:
		ARM64.HasCRC32 = true
	}

	switch extractBits(isar0, 20, 23) {
	case 2:
		ARM64.HasATOMICS = true
	}

	switch extractBits(isar0, 28, 31) {
	case 1:
		ARM64.HasASIMDRDM = true
	}

	switch extractBits(isar0, 32, 35) {
	case 1:
		ARM64.HasSHA3 = true
	}

	switch extractBits(isar0, 36, 39) {
	case 1:
		ARM64.HasSM3 = true
	}

	switch extractBits(isar0, 40, 43) {
	case 1:
		ARM64.HasSM4 = true
	}

	switch extractBits(isar0, 44, 47) {
	case 1:
		ARM64.HasASIMDDP = true
	}

	// ID_AA64ISAR1_EL1
	switch extractBits(isar1, 0, 3) {
	case 1:
		ARM64.HasDCPOP = true
	}

	switch extractBits(isar1, 12, 15) {
	case 1:
		ARM64.HasJSCVT = true
	}

	switch extractBits(isar1, 16, 19) {
	case 1:
		ARM64.HasFCMA = true
	}

	switch extractBits(isar1, 20, 23) {
	case 1:
		ARM64.HasLRCPC = true
	}

	switch extractBits(isar1, 52, 55) {
	case 1:
		ARM64.HasI8MM = true
	}

	// ID_AA64PFR0_EL1
	switch extractBits(pfr0, 16, 19) {
	case 0:
		ARM64.HasFP = true
	case 1:
		ARM64.HasFP = true
		ARM64.HasFPHP = true
	}

	switch extractBits(pfr0, 20, 23) {
	case 0:
		ARM64.HasASIMD = true
	case 1:
		ARM64.HasASIMD = true
		ARM64.HasASIMDHP = true
	}

	switch extractBits(pfr0, 32, 35) {
	case 1:
		ARM64.HasSVE = true

		parseARM64SVERegister(getzfr0())
	}

	switch extractBits(pfr0, 48, 51) {
	case 1:
		ARM64.HasDIT = true
	}
}

func parseARM64SVERegister(zfr0 uint64) {
	switch extractBits(zfr0, 0, 3) {
	case 1:
		ARM64.HasSVE2 = true
	}
}

func extractBits(data uint64, start, end uint) uint {
	return (uint)(data>>start) & ((1 << (end - start + 1)) - 1)
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_gccgo_s390x.go
File Name: cpu_gccgo_s390x.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build gccgo

package cpu

// haveAsmFunctions reports whether the other functions in this file can
// be safely called.
func haveAsmFunctions() bool { return false }

// TODO(mundaym): the following feature detection functions are currently
// stubs. See https://golang.org/cl/162887 for how to fix this.
// They are likely to be expensive to call so the results should be cached.
func stfle() facilityList     { panic("not implemented for gccgo") }
func kmQuery() queryResult    { panic("not implemented for gccgo") }
func kmcQuery() queryResult   { panic("not implemented for gccgo") }
func kmctrQuery() queryResult { panic("not implemented for gccgo") }
func kmaQuery() queryResult   { panic("not implemented for gccgo") }
func kimdQuery() queryResult  { panic("not implemented for gccgo") }
func klmdQuery() queryResult  { panic("not implemented for gccgo") }

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_s390x.go
File Name: cpu_s390x.go

===========================================

// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

const cacheLineSize = 256

func initOptions() {
	options = []option{
		{Name: "zarch", Feature: &S390X.HasZARCH, Required: true},
		{Name: "stfle", Feature: &S390X.HasSTFLE, Required: true},
		{Name: "ldisp", Feature: &S390X.HasLDISP, Required: true},
		{Name: "eimm", Feature: &S390X.HasEIMM, Required: true},
		{Name: "dfp", Feature: &S390X.HasDFP},
		{Name: "etf3eh", Feature: &S390X.HasETF3EH},
		{Name: "msa", Feature: &S390X.HasMSA},
		{Name: "aes", Feature: &S390X.HasAES},
		{Name: "aescbc", Feature: &S390X.HasAESCBC},
		{Name: "aesctr", Feature: &S390X.HasAESCTR},
		{Name: "aesgcm", Feature: &S390X.HasAESGCM},
		{Name: "ghash", Feature: &S390X.HasGHASH},
		{Name: "sha1", Feature: &S390X.HasSHA1},
		{Name: "sha256", Feature: &S390X.HasSHA256},
		{Name: "sha3", Feature: &S390X.HasSHA3},
		{Name: "sha512", Feature: &S390X.HasSHA512},
		{Name: "vx", Feature: &S390X.HasVX},
		{Name: "vxe", Feature: &S390X.HasVXE},
	}
}

// bitIsSet reports whether the bit at index is set. The bit index
// is in big endian order, so bit index 0 is the leftmost bit.
func bitIsSet(bits []uint64, index uint) bool {
	return bits[index/64]&((1<<63)>>(index%64)) != 0
}

// facility is a bit index for the named facility.
type facility uint8

const (
	// mandatory facilities
	zarch  facility = 1  // z architecture mode is active
	stflef facility = 7  // store-facility-list-extended
	ldisp  facility = 18 // long-displacement
	eimm   facility = 21 // extended-immediate

	// miscellaneous facilities
	dfp    facility = 42 // decimal-floating-point
	etf3eh facility = 30 // extended-translation 3 enhancement

	// cryptography facilities
	msa  facility = 17  // message-security-assist
	msa3 facility = 76  // message-security-assist extension 3
	msa4 facility = 77  // message-security-assist extension 4
	msa5 facility = 57  // message-security-assist extension 5
	msa8 facility = 146 // message-security-assist extension 8
	msa9 facility = 155 // message-security-assist extension 9

	// vector facilities
	vx   facility = 129 // vector facility
	vxe  facility = 135 // vector-enhancements 1
	vxe2 facility = 148 // vector-enhancements 2
)

// facilityList contains the result of an STFLE call.
// Bits are numbered in big endian order so the
// leftmost bit (the MSB) is at index 0.
type facilityList struct {
	bits [4]uint64
}

// Has reports whether the given facilities are present.
func (s *facilityList) Has(fs ...facility) bool {
	if len(fs) == 0 {
		panic("no facility bits provided")
	}
	for _, f := range fs {
		if !bitIsSet(s.bits[:], uint(f)) {
			return false
		}
	}
	return true
}

// function is the code for the named cryptographic function.
type function uint8

const (
	// KM{,A,C,CTR} function codes
	aes128 function = 18 // AES-128
	aes192 function = 19 // AES-192
	aes256 function = 20 // AES-256

	// K{I,L}MD function codes
	sha1     function = 1  // SHA-1
	sha256   function = 2  // SHA-256
	sha512   function = 3  // SHA-512
	sha3_224 function = 32 // SHA3-224
	sha3_256 function = 33 // SHA3-256
	sha3_384 function = 34 // SHA3-384
	sha3_512 function = 35 // SHA3-512
	shake128 function = 36 // SHAKE-128
	shake256 function = 37 // SHAKE-256

	// KLMD function codes
	ghash function = 65 // GHASH
)

// queryResult contains the result of a Query function
// call. Bits are numbered in big endian order so the
// leftmost bit (the MSB) is at index 0.
type queryResult struct {
	bits [2]uint64
}

// Has reports whether the given functions are present.
func (q *queryResult) Has(fns ...function) bool {
	if len(fns) == 0 {
		panic("no function codes provided")
	}
	for _, f := range fns {
		if !bitIsSet(q.bits[:], uint(f)) {
			return false
		}
	}
	return true
}

func doinit() {
	initS390Xbase()

	// We need implementations of stfle, km and so on
	// to detect cryptographic features.
	if !haveAsmFunctions() {
		return
	}

	// optional cryptographic functions
	if S390X.HasMSA {
		aes := []function{aes128, aes192, aes256}

		// cipher message
		km, kmc := kmQuery(), kmcQuery()
		S390X.HasAES = km.Has(aes...)
		S390X.HasAESCBC = kmc.Has(aes...)
		if S390X.HasSTFLE {
			facilities := stfle()
			if facilities.Has(msa4) {
				kmctr := kmctrQuery()
				S390X.HasAESCTR = kmctr.Has(aes...)
			}
			if facilities.Has(msa8) {
				kma := kmaQuery()
				S390X.HasAESGCM = kma.Has(aes...)
			}
		}

		// compute message digest
		kimd := kimdQuery() // intermediate (no padding)
		klmd := klmdQuery() // last (padding)
		S390X.HasSHA1 = kimd.Has(sha1) && klmd.Has(sha1)
		S390X.HasSHA256 = kimd.Has(sha256) && klmd.Has(sha256)
		S390X.HasSHA512 = kimd.Has(sha512) && klmd.Has(sha512)
		S390X.HasGHASH = kimd.Has(ghash) // KLMD-GHASH does not exist
		sha3 := []function{
			sha3_224, sha3_256, sha3_384, sha3_512,
			shake128, shake256,
		}
		S390X.HasSHA3 = kimd.Has(sha3...) && klmd.Has(sha3...)
	}
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/proc_cpuinfo_linux.go
File Name: proc_cpuinfo_linux.go

===========================================

// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && arm64

package cpu

import (
	"errors"
	"io"
	"os"
	"strings"
)

func readLinuxProcCPUInfo() error {
	f, err := os.Open("/proc/cpuinfo")
	if err != nil {
		return err
	}
	defer f.Close()

	var buf [1 << 10]byte // enough for first CPU
	n, err := io.ReadFull(f, buf[:])
	if err != nil && err != io.ErrUnexpectedEOF {
		return err
	}
	in := string(buf[:n])
	const features = "\nFeatures	: "
	i := strings.Index(in, features)
	if i == -1 {
		return errors.New("no CPU features found")
	}
	in = in[i+len(features):]
	if i := strings.Index(in, "\n"); i != -1 {
		in = in[:i]
	}
	m := map[string]*bool{}

	initOptions() // need it early here; it's harmless to call twice
	for _, o := range options {
		m[o.Name] = o.Feature
	}
	// The EVTSTRM field has alias "evstrm" in Go, but Linux calls it "evtstrm".
	m["evtstrm"] = &ARM64.HasEVTSTRM

	for _, f := range strings.Fields(in) {
		if p, ok := m[f]; ok {
			*p = true
		}
	}
	return nil
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_gccgo_arm64.go
File Name: cpu_gccgo_arm64.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build gccgo

package cpu

func getisar0() uint64 { return 0 }
func getisar1() uint64 { return 0 }
func getpfr0() uint64  { return 0 }

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_other_x86.go
File Name: cpu_other_x86.go

===========================================

// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build 386 || amd64p32 || (amd64 && (!darwin || !gc))

package cpu

func darwinSupportsAVX512() bool {
	panic("only implemented for gc && amd64 && darwin")
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_linux_noinit.go
File Name: cpu_linux_noinit.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && !arm && !arm64 && !mips64 && !mips64le && !ppc64 && !ppc64le && !s390x && !riscv64

package cpu

func doinit() {}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/endian_little.go
File Name: endian_little.go

===========================================

// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build 386 || amd64 || amd64p32 || alpha || arm || arm64 || loong64 || mipsle || mips64le || mips64p32le || nios2 || ppc64le || riscv || riscv64 || sh || wasm

package cpu

// IsBigEndian records whether the GOARCH's byte order is big endian.
const IsBigEndian = false

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_x86.go
File Name: cpu_x86.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build 386 || amd64 || amd64p32

package cpu

import "runtime"

const cacheLineSize = 64

func initOptions() {
	options = []option{
		{Name: "adx", Feature: &X86.HasADX},
		{Name: "aes", Feature: &X86.HasAES},
		{Name: "avx", Feature: &X86.HasAVX},
		{Name: "avx2", Feature: &X86.HasAVX2},
		{Name: "avx512", Feature: &X86.HasAVX512},
		{Name: "avx512f", Feature: &X86.HasAVX512F},
		{Name: "avx512cd", Feature: &X86.HasAVX512CD},
		{Name: "avx512er", Feature: &X86.HasAVX512ER},
		{Name: "avx512pf", Feature: &X86.HasAVX512PF},
		{Name: "avx512vl", Feature: &X86.HasAVX512VL},
		{Name: "avx512bw", Feature: &X86.HasAVX512BW},
		{Name: "avx512dq", Feature: &X86.HasAVX512DQ},
		{Name: "avx512ifma", Feature: &X86.HasAVX512IFMA},
		{Name: "avx512vbmi", Feature: &X86.HasAVX512VBMI},
		{Name: "avx512vnniw", Feature: &X86.HasAVX5124VNNIW},
		{Name: "avx5124fmaps", Feature: &X86.HasAVX5124FMAPS},
		{Name: "avx512vpopcntdq", Feature: &X86.HasAVX512VPOPCNTDQ},
		{Name: "avx512vpclmulqdq", Feature: &X86.HasAVX512VPCLMULQDQ},
		{Name: "avx512vnni", Feature: &X86.HasAVX512VNNI},
		{Name: "avx512gfni", Feature: &X86.HasAVX512GFNI},
		{Name: "avx512vaes", Feature: &X86.HasAVX512VAES},
		{Name: "avx512vbmi2", Feature: &X86.HasAVX512VBMI2},
		{Name: "avx512bitalg", Feature: &X86.HasAVX512BITALG},
		{Name: "avx512bf16", Feature: &X86.HasAVX512BF16},
		{Name: "amxtile", Feature: &X86.HasAMXTile},
		{Name: "amxint8", Feature: &X86.HasAMXInt8},
		{Name: "amxbf16", Feature: &X86.HasAMXBF16},
		{Name: "bmi1", Feature: &X86.HasBMI1},
		{Name: "bmi2", Feature: &X86.HasBMI2},
		{Name: "cx16", Feature: &X86.HasCX16},
		{Name: "erms", Feature: &X86.HasERMS},
		{Name: "fma", Feature: &X86.HasFMA},
		{Name: "osxsave", Feature: &X86.HasOSXSAVE},
		{Name: "pclmulqdq", Feature: &X86.HasPCLMULQDQ},
		{Name: "popcnt", Feature: &X86.HasPOPCNT},
		{Name: "rdrand", Feature: &X86.HasRDRAND},
		{Name: "rdseed", Feature: &X86.HasRDSEED},
		{Name: "sse3", Feature: &X86.HasSSE3},
		{Name: "sse41", Feature: &X86.HasSSE41},
		{Name: "sse42", Feature: &X86.HasSSE42},
		{Name: "ssse3", Feature: &X86.HasSSSE3},

		// These capabilities should always be enabled on amd64:
		{Name: "sse2", Feature: &X86.HasSSE2, Required: runtime.GOARCH == "amd64"},
	}
}

func archInit() {

	Initialized = true

	maxID, _, _, _ := cpuid(0, 0)

	if maxID < 1 {
		return
	}

	_, _, ecx1, edx1 := cpuid(1, 0)
	X86.HasSSE2 = isSet(26, edx1)

	X86.HasSSE3 = isSet(0, ecx1)
	X86.HasPCLMULQDQ = isSet(1, ecx1)
	X86.HasSSSE3 = isSet(9, ecx1)
	X86.HasFMA = isSet(12, ecx1)
	X86.HasCX16 = isSet(13, ecx1)
	X86.HasSSE41 = isSet(19, ecx1)
	X86.HasSSE42 = isSet(20, ecx1)
	X86.HasPOPCNT = isSet(23, ecx1)
	X86.HasAES = isSet(25, ecx1)
	X86.HasOSXSAVE = isSet(27, ecx1)
	X86.HasRDRAND = isSet(30, ecx1)

	var osSupportsAVX, osSupportsAVX512 bool
	// For XGETBV, OSXSAVE bit is required and sufficient.
	if X86.HasOSXSAVE {
		eax, _ := xgetbv()
		// Check if XMM and YMM registers have OS support.
		osSupportsAVX = isSet(1, eax) && isSet(2, eax)

		if runtime.GOOS == "darwin" {
			// Darwin requires special AVX512 checks, see cpu_darwin_x86.go
			osSupportsAVX512 = osSupportsAVX && darwinSupportsAVX512()
		} else {
			// Check if OPMASK and ZMM registers have OS support.
			osSupportsAVX512 = osSupportsAVX && isSet(5, eax) && isSet(6, eax) && isSet(7, eax)
		}
	}

	X86.HasAVX = isSet(28, ecx1) && osSupportsAVX

	if maxID < 7 {
		return
	}

	_, ebx7, ecx7, edx7 := cpuid(7, 0)
	X86.HasBMI1 = isSet(3, ebx7)
	X86.HasAVX2 = isSet(5, ebx7) && osSupportsAVX
	X86.HasBMI2 = isSet(8, ebx7)
	X86.HasERMS = isSet(9, ebx7)
	X86.HasRDSEED = isSet(18, ebx7)
	X86.HasADX = isSet(19, ebx7)

	X86.HasAVX512 = isSet(16, ebx7) && osSupportsAVX512 // Because avx-512 foundation is the core required extension
	if X86.HasAVX512 {
		X86.HasAVX512F = true
		X86.HasAVX512CD = isSet(28, ebx7)
		X86.HasAVX512ER = isSet(27, ebx7)
		X86.HasAVX512PF = isSet(26, ebx7)
		X86.HasAVX512VL = isSet(31, ebx7)
		X86.HasAVX512BW = isSet(30, ebx7)
		X86.HasAVX512DQ = isSet(17, ebx7)
		X86.HasAVX512IFMA = isSet(21, ebx7)
		X86.HasAVX512VBMI = isSet(1, ecx7)
		X86.HasAVX5124VNNIW = isSet(2, edx7)
		X86.HasAVX5124FMAPS = isSet(3, edx7)
		X86.HasAVX512VPOPCNTDQ = isSet(14, ecx7)
		X86.HasAVX512VPCLMULQDQ = isSet(10, ecx7)
		X86.HasAVX512VNNI = isSet(11, ecx7)
		X86.HasAVX512GFNI = isSet(8, ecx7)
		X86.HasAVX512VAES = isSet(9, ecx7)
		X86.HasAVX512VBMI2 = isSet(6, ecx7)
		X86.HasAVX512BITALG = isSet(12, ecx7)

		eax71, _, _, _ := cpuid(7, 1)
		X86.HasAVX512BF16 = isSet(5, eax71)
	}

	X86.HasAMXTile = isSet(24, edx7)
	X86.HasAMXInt8 = isSet(25, edx7)
	X86.HasAMXBF16 = isSet(22, edx7)
}

func isSet(bitpos uint, value uint32) bool {
	return value&(1<<bitpos) != 0
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_aix.go
File Name: cpu_aix.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build aix

package cpu

const (
	// getsystemcfg constants
	_SC_IMPL     = 2
	_IMPL_POWER8 = 0x10000
	_IMPL_POWER9 = 0x20000
)

func archInit() {
	impl := getsystemcfg(_SC_IMPL)
	if impl&_IMPL_POWER8 != 0 {
		PPC64.IsPOWER8 = true
	}
	if impl&_IMPL_POWER9 != 0 {
		PPC64.IsPOWER8 = true
		PPC64.IsPOWER9 = true
	}

	Initialized = true
}

func getsystemcfg(label int) (n uint64) {
	r0, _ := callgetsystemcfg(label)
	n = uint64(r0)
	return
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/syscall_aix_ppc64_gc.go
File Name: syscall_aix_ppc64_gc.go

===========================================

// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Minimal copy of x/sys/unix so the cpu package can make a
// system call on AIX without depending on x/sys/unix.
// (See golang.org/issue/32102)

//go:build aix && ppc64 && gc

package cpu

import (
	"syscall"
	"unsafe"
)

//go:cgo_import_dynamic libc_getsystemcfg getsystemcfg "libc.a/shr_64.o"

//go:linkname libc_getsystemcfg libc_getsystemcfg

type syscallFunc uintptr

var libc_getsystemcfg syscallFunc

type errno = syscall.Errno

// Implemented in runtime/syscall_aix.go.
func rawSyscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err errno)
func syscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err errno)

func callgetsystemcfg(label int) (r1 uintptr, e1 errno) {
	r1, _, e1 = syscall6(uintptr(unsafe.Pointer(&libc_getsystemcfg)), 1, uintptr(label), 0, 0, 0, 0, 0)
	return
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/parse.go
File Name: parse.go

===========================================

// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import "strconv"

// parseRelease parses a dot-separated version number. It follows the semver
// syntax, but allows the minor and patch versions to be elided.
//
// This is a copy of the Go runtime's parseRelease from
// https://golang.org/cl/209597.
func parseRelease(rel string) (major, minor, patch int, ok bool) {
	// Strip anything after a dash or plus.
	for i := 0; i < len(rel); i++ {
		if rel[i] == '-' || rel[i] == '+' {
			rel = rel[:i]
			break
		}
	}

	next := func() (int, bool) {
		for i := 0; i < len(rel); i++ {
			if rel[i] == '.' {
				ver, err := strconv.Atoi(rel[:i])
				rel = rel[i+1:]
				return ver, err == nil
			}
		}
		ver, err := strconv.Atoi(rel)
		rel = ""
		return ver, err == nil
	}
	if major, ok = next(); !ok || rel == "" {
		return
	}
	if minor, ok = next(); !ok || rel == "" {
		return
	}
	patch, ok = next()
	return
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_openbsd_arm64.go
File Name: cpu_openbsd_arm64.go

===========================================

// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cpu

import (
	"syscall"
	"unsafe"
)

// Minimal copy of functionality from x/sys/unix so the cpu package can call
// sysctl without depending on x/sys/unix.

const (
	// From OpenBSD's sys/sysctl.h.
	_CTL_MACHDEP = 7

	// From OpenBSD's machine/cpu.h.
	_CPU_ID_AA64ISAR0 = 2
	_CPU_ID_AA64ISAR1 = 3
)

// Implemented in the runtime package (runtime/sys_openbsd3.go)
func syscall_syscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)

//go:linkname syscall_syscall6 syscall.syscall6

func sysctl(mib []uint32, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) {
	_, _, errno := syscall_syscall6(libc_sysctl_trampoline_addr, uintptr(unsafe.Pointer(&mib[0])), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))
	if errno != 0 {
		return errno
	}
	return nil
}

var libc_sysctl_trampoline_addr uintptr

//go:cgo_import_dynamic libc_sysctl sysctl "libc.so"

func sysctlUint64(mib []uint32) (uint64, bool) {
	var out uint64
	nout := unsafe.Sizeof(out)
	if err := sysctl(mib, (*byte)(unsafe.Pointer(&out)), &nout, nil, 0); err != nil {
		return 0, false
	}
	return out, true
}

func doinit() {
	setMinimalFeatures()

	// Get ID_AA64ISAR0 and ID_AA64ISAR1 from sysctl.
	isar0, ok := sysctlUint64([]uint32{_CTL_MACHDEP, _CPU_ID_AA64ISAR0})
	if !ok {
		return
	}
	isar1, ok := sysctlUint64([]uint32{_CTL_MACHDEP, _CPU_ID_AA64ISAR1})
	if !ok {
		return
	}
	parseARM64SystemRegisters(isar0, isar1, 0)

	Initialized = true
}

===========================================

File Path: ./vendor/golang.org/x/sys/cpu/cpu_gccgo_x86.go
File Name: cpu_gccgo_x86.go

===========================================

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build (386 || amd64 || amd64p32) && gccgo

package cpu

//extern gccgoGetCpuidCount
func gccgoGetCpuidCount(eaxArg, ecxArg uint32, eax, ebx, ecx, edx *uint32)

func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32) {
	var a, b, c, d uint32
	gccgoGetCpuidCount(eaxArg, ecxArg, &a, &b, &c, &d)
	return a, b, c, d
}

//extern gccgoXgetbv
func gccgoXgetbv(eax, edx *uint32)

func xgetbv() (eax, edx uint32) {
	var a, d uint32
	gccgoXgetbv(&a, &d)
	return a, d
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/optate.go
File Name: optate.go

===========================================

package bn256

func lineFunctionAdd(r, p *twistPoint, q *curvePoint, r2 *gfP2) (a, b, c *gfP2, rOut *twistPoint) {
	// See the mixed addition algorithm from "Faster Computation of the
	// Tate Pairing", http://arxiv.org/pdf/0904.0854v3.pdf
	B := (&gfP2{}).Mul(&p.x, &r.t)

	D := (&gfP2{}).Add(&p.y, &r.z)
	D.Square(D).Sub(D, r2).Sub(D, &r.t).Mul(D, &r.t)

	H := (&gfP2{}).Sub(B, &r.x)
	I := (&gfP2{}).Square(H)

	E := (&gfP2{}).Add(I, I)
	E.Add(E, E)

	J := (&gfP2{}).Mul(H, E)

	L1 := (&gfP2{}).Sub(D, &r.y)
	L1.Sub(L1, &r.y)

	V := (&gfP2{}).Mul(&r.x, E)

	rOut = &twistPoint{}
	rOut.x.Square(L1).Sub(&rOut.x, J).Sub(&rOut.x, V).Sub(&rOut.x, V)

	rOut.z.Add(&r.z, H).Square(&rOut.z).Sub(&rOut.z, &r.t).Sub(&rOut.z, I)

	t := (&gfP2{}).Sub(V, &rOut.x)
	t.Mul(t, L1)
	t2 := (&gfP2{}).Mul(&r.y, J)
	t2.Add(t2, t2)
	rOut.y.Sub(t, t2)

	rOut.t.Square(&rOut.z)

	t.Add(&p.y, &rOut.z).Square(t).Sub(t, r2).Sub(t, &rOut.t)

	t2.Mul(L1, &p.x)
	t2.Add(t2, t2)
	a = (&gfP2{}).Sub(t2, t)

	c = (&gfP2{}).MulScalar(&rOut.z, &q.y)
	c.Add(c, c)

	b = (&gfP2{}).Neg(L1)
	b.MulScalar(b, &q.x).Add(b, b)

	return
}

func lineFunctionDouble(r *twistPoint, q *curvePoint) (a, b, c *gfP2, rOut *twistPoint) {
	// See the doubling algorithm for a=0 from "Faster Computation of the
	// Tate Pairing", http://arxiv.org/pdf/0904.0854v3.pdf
	A := (&gfP2{}).Square(&r.x)
	B := (&gfP2{}).Square(&r.y)
	C := (&gfP2{}).Square(B)

	D := (&gfP2{}).Add(&r.x, B)
	D.Square(D).Sub(D, A).Sub(D, C).Add(D, D)

	E := (&gfP2{}).Add(A, A)
	E.Add(E, A)

	G := (&gfP2{}).Square(E)

	rOut = &twistPoint{}
	rOut.x.Sub(G, D).Sub(&rOut.x, D)

	rOut.z.Add(&r.y, &r.z).Square(&rOut.z).Sub(&rOut.z, B).Sub(&rOut.z, &r.t)

	rOut.y.Sub(D, &rOut.x).Mul(&rOut.y, E)
	t := (&gfP2{}).Add(C, C)
	t.Add(t, t).Add(t, t)
	rOut.y.Sub(&rOut.y, t)

	rOut.t.Square(&rOut.z)

	t.Mul(E, &r.t).Add(t, t)
	b = (&gfP2{}).Neg(t)
	b.MulScalar(b, &q.x)

	a = (&gfP2{}).Add(&r.x, E)
	a.Square(a).Sub(a, A).Sub(a, G)
	t.Add(B, B).Add(t, t)
	a.Sub(a, t)

	c = (&gfP2{}).Mul(&rOut.z, &r.t)
	c.Add(c, c).MulScalar(c, &q.y)

	return
}

func mulLine(ret *gfP12, a, b, c *gfP2) {
	a2 := &gfP6{}
	a2.y.Set(a)
	a2.z.Set(b)
	a2.Mul(a2, &ret.x)
	t3 := (&gfP6{}).MulScalar(&ret.y, c)

	t := (&gfP2{}).Add(b, c)
	t2 := &gfP6{}
	t2.y.Set(a)
	t2.z.Set(t)
	ret.x.Add(&ret.x, &ret.y)

	ret.y.Set(t3)

	ret.x.Mul(&ret.x, t2).Sub(&ret.x, a2).Sub(&ret.x, &ret.y)
	a2.MulTau(a2)
	ret.y.Add(&ret.y, a2)
}

// sixuPlus2NAF is 6u+2 in non-adjacent form.
var sixuPlus2NAF = []int8{0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 1, 0, -1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 1}

// miller implements the Miller loop for calculating the Optimal Ate pairing.
// See algorithm 1 from http://cryptojedi.org/papers/dclxvi-20100714.pdf
func miller(q *twistPoint, p *curvePoint) *gfP12 {
	ret := (&gfP12{}).SetOne()

	aAffine := &twistPoint{}
	aAffine.Set(q)
	aAffine.MakeAffine()

	bAffine := &curvePoint{}
	bAffine.Set(p)
	bAffine.MakeAffine()

	minusA := &twistPoint{}
	minusA.Neg(aAffine)

	r := &twistPoint{}
	r.Set(aAffine)

	r2 := (&gfP2{}).Square(&aAffine.y)

	for i := len(sixuPlus2NAF) - 1; i > 0; i-- {
		a, b, c, newR := lineFunctionDouble(r, bAffine)
		if i != len(sixuPlus2NAF)-1 {
			ret.Square(ret)
		}

		mulLine(ret, a, b, c)
		r = newR

		switch sixuPlus2NAF[i-1] {
		case 1:
			a, b, c, newR = lineFunctionAdd(r, aAffine, bAffine, r2)
		case -1:
			a, b, c, newR = lineFunctionAdd(r, minusA, bAffine, r2)
		default:
			continue
		}

		mulLine(ret, a, b, c)
		r = newR
	}

	// In order to calculate Q1 we have to convert q from the sextic twist
	// to the full GF(p^12) group, apply the Frobenius there, and convert
	// back.
	//
	// The twist isomorphism is (x', y') -> (x, y). If we consider just
	// x for a moment, then after applying the Frobenius, we have x^(2p)
	// where x is the conjugate of x. If we are going to apply the inverse
	// isomorphism we need a value with a single coefficient of  so we
	// rewrite this as x^(2p-2).  =  and, due to the construction of
	// p, 2p-2 is a multiple of six. Therefore we can rewrite as
	// x^((p-1)/3) and applying the inverse isomorphism eliminates the
	// .
	//
	// A similar argument can be made for the y value.

	q1 := &twistPoint{}
	q1.x.Conjugate(&aAffine.x).Mul(&q1.x, xiToPMinus1Over3)
	q1.y.Conjugate(&aAffine.y).Mul(&q1.y, xiToPMinus1Over2)
	q1.z.SetOne()
	q1.t.SetOne()

	// For Q2 we are applying the p Frobenius. The two conjugations cancel
	// out and we are left only with the factors from the isomorphism. In
	// the case of x, we end up with a pure number which is why
	// xiToPSquaredMinus1Over3 is  GF(p). With y we get a factor of -1. We
	// ignore this to end up with -Q2.

	minusQ2 := &twistPoint{}
	minusQ2.x.MulScalar(&aAffine.x, xiToPSquaredMinus1Over3)
	minusQ2.y.Set(&aAffine.y)
	minusQ2.z.SetOne()
	minusQ2.t.SetOne()

	r2.Square(&q1.y)
	a, b, c, newR := lineFunctionAdd(r, q1, bAffine, r2)
	mulLine(ret, a, b, c)
	r = newR

	r2.Square(&minusQ2.y)
	a, b, c, _ = lineFunctionAdd(r, minusQ2, bAffine, r2)
	mulLine(ret, a, b, c)

	return ret
}

// finalExponentiation computes the (p-1)/Order-th power of an element of
// GF(p) to obtain an element of GT (steps 13-15 of algorithm 1 from
// http://cryptojedi.org/papers/dclxvi-20100714.pdf)
func finalExponentiation(in *gfP12) *gfP12 {
	t1 := &gfP12{}

	// This is the p^6-Frobenius
	t1.x.Neg(&in.x)
	t1.y.Set(&in.y)

	inv := &gfP12{}
	inv.Invert(in)
	t1.Mul(t1, inv)

	t2 := (&gfP12{}).FrobeniusP2(t1)
	t1.Mul(t1, t2)

	fp := (&gfP12{}).Frobenius(t1)
	fp2 := (&gfP12{}).FrobeniusP2(t1)
	fp3 := (&gfP12{}).Frobenius(fp2)

	fu := (&gfP12{}).Exp(t1, u)
	fu2 := (&gfP12{}).Exp(fu, u)
	fu3 := (&gfP12{}).Exp(fu2, u)

	y3 := (&gfP12{}).Frobenius(fu)
	fu2p := (&gfP12{}).Frobenius(fu2)
	fu3p := (&gfP12{}).Frobenius(fu3)
	y2 := (&gfP12{}).FrobeniusP2(fu2)

	y0 := &gfP12{}
	y0.Mul(fp, fp2).Mul(y0, fp3)

	y1 := (&gfP12{}).Conjugate(t1)
	y5 := (&gfP12{}).Conjugate(fu2)
	y3.Conjugate(y3)
	y4 := (&gfP12{}).Mul(fu, fu2p)
	y4.Conjugate(y4)

	y6 := (&gfP12{}).Mul(fu3, fu3p)
	y6.Conjugate(y6)

	t0 := (&gfP12{}).Square(y6)
	t0.Mul(t0, y4).Mul(t0, y5)
	t1.Mul(y3, y5).Mul(t1, t0)
	t0.Mul(t0, y2)
	t1.Square(t1).Mul(t1, t0).Square(t1)
	t0.Mul(t1, y1)
	t1.Mul(t1, y0)
	t0.Square(t0).Mul(t0, t1)

	return t0
}

func optimalAte(a *twistPoint, b *curvePoint) *gfP12 {
	e := miller(a, b)
	ret := finalExponentiation(e)

	if a.IsInfinity() || b.IsInfinity() {
		ret.SetOne()
	}
	return ret
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/gfp_decl.go
File Name: gfp_decl.go

===========================================

// +build amd64,!generic arm64,!generic

package bn256

// This file contains forward declarations for the architecture-specific
// assembly implementations of these functions, provided that they exist.

import (
	"golang.org/x/sys/cpu"
)

var hasBMI2 = cpu.X86.HasBMI2

//go:noescape
func gfpNeg(c, a *gfP)

//go:noescape
func gfpAdd(c, a, b *gfP)

//go:noescape
func gfpSub(c, a, b *gfP)

//go:noescape
func gfpMul(c, a, b *gfP)

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/gfp_generic.go
File Name: gfp_generic.go

===========================================

// +build !amd64,!arm64 generic

package bn256

func gfpCarry(a *gfP, head uint64) {
	b := &gfP{}

	var carry uint64
	for i, pi := range p2 {
		ai := a[i]
		bi := ai - pi - carry
		b[i] = bi
		carry = (pi&^ai | (pi|^ai)&bi) >> 63
	}
	carry = carry &^ head

	// If b is negative, then return a.
	// Else return b.
	carry = -carry
	ncarry := ^carry
	for i := 0; i < 4; i++ {
		a[i] = (a[i] & carry) | (b[i] & ncarry)
	}
}

func gfpNeg(c, a *gfP) {
	var carry uint64
	for i, pi := range p2 {
		ai := a[i]
		ci := pi - ai - carry
		c[i] = ci
		carry = (ai&^pi | (ai|^pi)&ci) >> 63
	}
	gfpCarry(c, 0)
}

func gfpAdd(c, a, b *gfP) {
	var carry uint64
	for i, ai := range a {
		bi := b[i]
		ci := ai + bi + carry
		c[i] = ci
		carry = (ai&bi | (ai|bi)&^ci) >> 63
	}
	gfpCarry(c, carry)
}

func gfpSub(c, a, b *gfP) {
	t := &gfP{}

	var carry uint64
	for i, pi := range p2 {
		bi := b[i]
		ti := pi - bi - carry
		t[i] = ti
		carry = (bi&^pi | (bi|^pi)&ti) >> 63
	}

	carry = 0
	for i, ai := range a {
		ti := t[i]
		ci := ai + ti + carry
		c[i] = ci
		carry = (ai&ti | (ai|ti)&^ci) >> 63
	}
	gfpCarry(c, carry)
}

func mul(a, b [4]uint64) [8]uint64 {
	const (
		mask16 uint64 = 0x0000ffff
		mask32 uint64 = 0xffffffff
	)

	var buff [32]uint64
	for i, ai := range a {
		a0, a1, a2, a3 := ai&mask16, (ai>>16)&mask16, (ai>>32)&mask16, ai>>48

		for j, bj := range b {
			b0, b2 := bj&mask32, bj>>32

			off := 4 * (i + j)
			buff[off+0] += a0 * b0
			buff[off+1] += a1 * b0
			buff[off+2] += a2*b0 + a0*b2
			buff[off+3] += a3*b0 + a1*b2
			buff[off+4] += a2 * b2
			buff[off+5] += a3 * b2
		}
	}

	for i := uint(1); i < 4; i++ {
		shift := 16 * i

		var head, carry uint64
		for j := uint(0); j < 8; j++ {
			block := 4 * j

			xi := buff[block]
			yi := (buff[block+i] << shift) + head
			zi := xi + yi + carry
			buff[block] = zi
			carry = (xi&yi | (xi|yi)&^zi) >> 63

			head = buff[block+i] >> (64 - shift)
		}
	}

	return [8]uint64{buff[0], buff[4], buff[8], buff[12], buff[16], buff[20], buff[24], buff[28]}
}

func halfMul(a, b [4]uint64) [4]uint64 {
	const (
		mask16 uint64 = 0x0000ffff
		mask32 uint64 = 0xffffffff
	)

	var buff [18]uint64
	for i, ai := range a {
		a0, a1, a2, a3 := ai&mask16, (ai>>16)&mask16, (ai>>32)&mask16, ai>>48

		for j, bj := range b {
			if i+j > 3 {
				break
			}
			b0, b2 := bj&mask32, bj>>32

			off := 4 * (i + j)
			buff[off+0] += a0 * b0
			buff[off+1] += a1 * b0
			buff[off+2] += a2*b0 + a0*b2
			buff[off+3] += a3*b0 + a1*b2
			buff[off+4] += a2 * b2
			buff[off+5] += a3 * b2
		}
	}

	for i := uint(1); i < 4; i++ {
		shift := 16 * i

		var head, carry uint64
		for j := uint(0); j < 4; j++ {
			block := 4 * j

			xi := buff[block]
			yi := (buff[block+i] << shift) + head
			zi := xi + yi + carry
			buff[block] = zi
			carry = (xi&yi | (xi|yi)&^zi) >> 63

			head = buff[block+i] >> (64 - shift)
		}
	}

	return [4]uint64{buff[0], buff[4], buff[8], buff[12]}
}

func gfpMul(c, a, b *gfP) {
	T := mul(*a, *b)
	m := halfMul([4]uint64{T[0], T[1], T[2], T[3]}, np)
	t := mul([4]uint64{m[0], m[1], m[2], m[3]}, p2)

	var carry uint64
	for i, Ti := range T {
		ti := t[i]
		zi := Ti + ti + carry
		T[i] = zi
		carry = (Ti&ti | (Ti|ti)&^zi) >> 63
	}

	*c = gfP{T[4], T[5], T[6], T[7]}
	gfpCarry(c, carry)
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/twist.go
File Name: twist.go

===========================================

package bn256

import (
	"math/big"
)

// twistPoint implements the elliptic curve y=x+3/ over GF(p). Points are
// kept in Jacobian form and t=z when valid. The group G is the set of
// n-torsion points of this curve over GF(p) (where n = Order)
type twistPoint struct {
	x, y, z, t gfP2
}

var twistB = &gfP2{
	gfP{0x75046774386b8d71, 0x5bd0854a46d36cf8, 0x664327a1d41c8414, 0x96c9abb932eeb2f},
	gfP{0xb94f760fb4c5ee14, 0xdae9f8f24c3b6eb4, 0x77a675d2e52f4fe4, 0x736f31b09116c66b},
}

// twistGen is the generator of group G.
var twistGen = &twistPoint{
	gfP2{
		gfP{0x402c4ab7139e1404, 0xce1c368a183d85a4, 0xd67cf9a6cb8d3983, 0x3cf246bbc2a9fbe8},
		gfP{0x88f9f11da7cdc184, 0x18293f95d69509d3, 0xb5ce0c55a735d5a1, 0x15134189bfd45a0},
	},
	gfP2{
		gfP{0xbfac7d731e9e87a2, 0xa50bb8007962e441, 0xafe910a4e8270556, 0x5075c5429d69159a},
		gfP{0xc2e07c1463ea9e56, 0xee4442052072ebd2, 0x561a519486036937, 0x5bd9394cc0d2cce},
	},
	gfP2{*newGFp(0), *newGFp(1)},
	gfP2{*newGFp(0), *newGFp(1)},
}

func (c *twistPoint) String() string {
	c.MakeAffine()
	x, y := gfP2Decode(&c.x), gfP2Decode(&c.y)
	return "(" + x.String() + ", " + y.String() + ")"
}

func (c *twistPoint) Set(a *twistPoint) {
	c.x.Set(&a.x)
	c.y.Set(&a.y)
	c.z.Set(&a.z)
	c.t.Set(&a.t)
}

// IsOnCurve returns true iff c is on the curve.
func (c *twistPoint) IsOnCurve() bool {
	c.MakeAffine()
	if c.IsInfinity() {
		return true
	}

	y2, x3 := &gfP2{}, &gfP2{}
	y2.Square(&c.y)
	x3.Square(&c.x).Mul(x3, &c.x).Add(x3, twistB)

	return *y2 == *x3
}

func (c *twistPoint) SetInfinity() {
	c.x.SetZero()
	c.y.SetOne()
	c.z.SetZero()
	c.t.SetZero()
}

func (c *twistPoint) IsInfinity() bool {
	return c.z.IsZero()
}

func (c *twistPoint) Add(a, b *twistPoint) {
	// For additional comments, see the same function in curve.go.

	if a.IsInfinity() {
		c.Set(b)
		return
	}
	if b.IsInfinity() {
		c.Set(a)
		return
	}

	// See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2007-bl.op3
	z12 := (&gfP2{}).Square(&a.z)
	z22 := (&gfP2{}).Square(&b.z)
	u1 := (&gfP2{}).Mul(&a.x, z22)
	u2 := (&gfP2{}).Mul(&b.x, z12)

	t := (&gfP2{}).Mul(&b.z, z22)
	s1 := (&gfP2{}).Mul(&a.y, t)

	t.Mul(&a.z, z12)
	s2 := (&gfP2{}).Mul(&b.y, t)

	h := (&gfP2{}).Sub(u2, u1)
	xEqual := h.IsZero()

	t.Add(h, h)
	i := (&gfP2{}).Square(t)
	j := (&gfP2{}).Mul(h, i)

	t.Sub(s2, s1)
	yEqual := t.IsZero()
	if xEqual && yEqual {
		c.Double(a)
		return
	}
	r := (&gfP2{}).Add(t, t)

	v := (&gfP2{}).Mul(u1, i)

	t4 := (&gfP2{}).Square(r)
	t.Add(v, v)
	t6 := (&gfP2{}).Sub(t4, j)
	c.x.Sub(t6, t)

	t.Sub(v, &c.x) // t7
	t4.Mul(s1, j)  // t8
	t6.Add(t4, t4) // t9
	t4.Mul(r, t)   // t10
	c.y.Sub(t4, t6)

	t.Add(&a.z, &b.z) // t11
	t4.Square(t)      // t12
	t.Sub(t4, z12)    // t13
	t4.Sub(t, z22)    // t14
	c.z.Mul(t4, h)
}

func (c *twistPoint) Double(a *twistPoint) {
	// See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/doubling/dbl-2009-l.op3
	A := (&gfP2{}).Square(&a.x)
	B := (&gfP2{}).Square(&a.y)
	C := (&gfP2{}).Square(B)

	t := (&gfP2{}).Add(&a.x, B)
	t2 := (&gfP2{}).Square(t)
	t.Sub(t2, A)
	t2.Sub(t, C)
	d := (&gfP2{}).Add(t2, t2)
	t.Add(A, A)
	e := (&gfP2{}).Add(t, A)
	f := (&gfP2{}).Square(e)

	t.Add(d, d)
	c.x.Sub(f, t)

	c.z.Mul(&a.y, &a.z)
	c.z.Add(&c.z, &c.z)

	t.Add(C, C)
	t2.Add(t, t)
	t.Add(t2, t2)
	c.y.Sub(d, &c.x)
	t2.Mul(e, &c.y)
	c.y.Sub(t2, t)
}

func (c *twistPoint) Mul(a *twistPoint, scalar *big.Int) {
	sum, t := &twistPoint{}, &twistPoint{}

	for i := scalar.BitLen(); i >= 0; i-- {
		t.Double(sum)
		if scalar.Bit(i) != 0 {
			sum.Add(t, a)
		} else {
			sum.Set(t)
		}
	}

	c.Set(sum)
}

func (c *twistPoint) MakeAffine() {
	if c.z.IsOne() {
		return
	} else if c.z.IsZero() {
		c.x.SetZero()
		c.y.SetOne()
		c.t.SetZero()
		return
	}

	zInv := (&gfP2{}).Invert(&c.z)
	t := (&gfP2{}).Mul(&c.y, zInv)
	zInv2 := (&gfP2{}).Square(zInv)
	c.y.Mul(t, zInv2)
	t.Mul(&c.x, zInv2)
	c.x.Set(t)
	c.z.SetOne()
	c.t.SetOne()
}

func (c *twistPoint) Neg(a *twistPoint) {
	c.x.Set(&a.x)
	c.y.Neg(&a.y)
	c.z.Set(&a.z)
	c.t.SetZero()
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/constants.go
File Name: constants.go

===========================================

package bn256

import (
	"math/big"
)

func bigFromBase10(s string) *big.Int {
	n, _ := new(big.Int).SetString(s, 10)
	return n
}

// u is the BN parameter that determines the prime: 1868033.
var u = bigFromBase10("6518589491078791937")

// p is a prime over which we form a basic field: 36u+36u+24u+6u+1.
var p = bigFromBase10("65000549695646603732796438742359905742825358107623003571877145026864184071783")

// Order is the number of elements in both G and G: 36u+36u+18u+6u+1.
// order-1 = (2**5) * 3 * 5743 * 280941149 * 130979359433191 * 491513138693455212421542731357 * 6518589491078791937
var Order = bigFromBase10("65000549695646603732796438742359905742570406053903786389881062969044166799969")

// xiToPMinus1Over6 is ^((p-1)/6) where  = i+3.
var xiToPMinus1Over6 = &gfP2{gfP{0x25af52988477cdb7, 0x3d81a455ddced86a, 0x227d012e872c2431, 0x179198d3ea65d05}, gfP{0x7407634dd9cca958, 0x36d5bd6c7afb8f26, 0xf4b1c32cebd880fa, 0x6aa7869306f455f}}

// xiToPMinus1Over3 is ^((p-1)/3) where  = i+3.
var xiToPMinus1Over3 = &gfP2{gfP{0x4f59e37c01832e57, 0xae6be39ac2bbbfe4, 0xe04ea1bb697512f8, 0x3097caa8fc40e10e}, gfP{0xf8606916d3816f2c, 0x1e5c0d7926de927e, 0xbc45f3946d81185e, 0x80752a25aa738091}}

// xiToPMinus1Over2 is ^((p-1)/2) where  = i+3.
var xiToPMinus1Over2 = &gfP2{gfP{0x19da71333653ee20, 0x7eaaf34fc6ed6019, 0xc4ba3a29a60cdd1d, 0x75281311bcc9df79}, gfP{0x18dbee03fb7708fa, 0x1e7601a602c843c7, 0x5dde0688cdb231cb, 0x86db5cf2c605a524}}

// xiToPSquaredMinus1Over3 is ^((p-1)/3) where  = i+3.
var xiToPSquaredMinus1Over3 = &gfP{0x12d3cef5e1ada57d, 0xe2eca1463753babb, 0xca41e40ddccf750, 0x551337060397e04c}

// xiTo2PSquaredMinus2Over3 is ^((2p-2)/3) where  = i+3 (a cubic root of unity, mod p).
var xiTo2PSquaredMinus2Over3 = &gfP{0x3642364f386c1db8, 0xe825f92d2acd661f, 0xf2aba7e846c19d14, 0x5a0bcea3dc52b7a0}

// xiToPSquaredMinus1Over6 is ^((1p-1)/6) where  = i+3 (a cubic root of -1, mod p).
var xiToPSquaredMinus1Over6 = &gfP{0xe21a761d259c78af, 0x6358fa3f5e84f7e, 0xb7c444d01ac33f0d, 0x35a9333f6e50d058}

// xiTo2PMinus2Over3 is ^((2p-2)/3) where  = i+3.
var xiTo2PMinus2Over3 = &gfP2{gfP{0x51678e7469b3c52a, 0x4fb98f8b13319fc9, 0x29b2254db3f1df75, 0x1c044935a3d22fb2}, gfP{0x4d2ea218872f3d2c, 0x2fcb27fc4abe7b69, 0xd31d972f0e88ced9, 0x53adc04a00a73b15}}

// p2 is p, represented as little-endian 64-bit words.
var p2 = [4]uint64{0x185cac6c5e089667, 0xee5b88d120b5b59e, 0xaa6fecb86184dc21, 0x8fb501e34aa387f9}

// np is the negative inverse of p, mod 2^256.
var np = [4]uint64{0x2387f9007f17daa9, 0x734b3343ab8513c8, 0x2524282f48054c12, 0x38997ae661c3ef3c}

// rN1 is R^-1 where R = 2^256 mod p.
var rN1 = &gfP{0xcbb781e36236117d, 0xcc65f3bcec8c91b, 0x2eab68888ea1f515, 0x1fc5c0956f92f825}

// r2 is R^2 where R = 2^256 mod p.
var r2 = &gfP{0x9c21c3ff7e444f56, 0x409ed151b2efb0c2, 0xc6dc37b80fb1651, 0x7c36e0e62c2380b7}

// r3 is R^3 where R = 2^256 mod p.
var r3 = &gfP{0x2af2dfb9324a5bb8, 0x388f899054f538a4, 0xdf2ff66396b107a7, 0x24ebbbb3a2529292}

// pPlus1Over4 is (p+1)/4.
var pPlus1Over4 = [4]uint64{0x86172b1b1782259a, 0x7b96e234482d6d67, 0x6a9bfb2e18613708, 0x23ed4078d2a8e1fe}

// pMinus2 is p-2.
var pMinus2 = [4]uint64{0x185cac6c5e089665, 0xee5b88d120b5b59e, 0xaa6fecb86184dc21, 0x8fb501e34aa387f9}

// pMinus1Over2 is (p-1)/2.
var pMinus1Over2 = [4]uint64{0x0c2e56362f044b33, 0xf72dc468905adacf, 0xd537f65c30c26e10, 0x47da80f1a551c3fc}

// s is the Montgomery encoding of the square root of -3. Then, s = sqrt(-3) * 2^256 mod p.
var s = &gfP{0x236e675956be783b, 0x053957e6f379ab64, 0xe60789a768f4a5c4, 0x04f8979dd8bad754}

// sMinus1Over2 is the Montgomery encoding of (s-1)/2. Then, sMinus1Over2 = ( (s-1) / 2) * 2^256 mod p.
var sMinus1Over2 = &gfP{0x3642364f386c1db8, 0xe825f92d2acd661f, 0xf2aba7e846c19d14, 0x5a0bcea3dc52b7a0}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/curve.go
File Name: curve.go

===========================================

package bn256

import (
	"math/big"
)

// curvePoint implements the elliptic curve y=x+3. Points are kept in Jacobian
// form and t=z when valid. G is the set of points of this curve on GF(p).
type curvePoint struct {
	x, y, z, t gfP
}

var curveB = newGFp(3)

// curveGen is the generator of G.
var curveGen = &curvePoint{
	x: *newGFp(1),
	y: *newGFp(-2),
	z: *newGFp(1),
	t: *newGFp(1),
}

func (c *curvePoint) String() string {
	c.MakeAffine()
	x, y := &gfP{}, &gfP{}
	montDecode(x, &c.x)
	montDecode(y, &c.y)
	return "(" + x.String() + ", " + y.String() + ")"
}

func (c *curvePoint) Set(a *curvePoint) {
	c.x.Set(&a.x)
	c.y.Set(&a.y)
	c.z.Set(&a.z)
	c.t.Set(&a.t)
}

// IsOnCurve returns true iff c is on the curve.
func (c *curvePoint) IsOnCurve() bool {
	c.MakeAffine()
	if c.IsInfinity() {
		return true
	}

	y2, x3 := &gfP{}, &gfP{}
	gfpMul(y2, &c.y, &c.y)
	gfpMul(x3, &c.x, &c.x)
	gfpMul(x3, x3, &c.x)
	gfpAdd(x3, x3, curveB)

	return *y2 == *x3
}

func (c *curvePoint) SetInfinity() {
	c.x = gfP{0}
	c.y = *newGFp(1)
	c.z = gfP{0}
	c.t = gfP{0}
}

func (c *curvePoint) IsInfinity() bool {
	return c.z == gfP{0}
}

func (c *curvePoint) Add(a, b *curvePoint) {
	if a.IsInfinity() {
		c.Set(b)
		return
	}
	if b.IsInfinity() {
		c.Set(a)
		return
	}

	// See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2007-bl.op3

	// Normalize the points by replacing a = [x1:y1:z1] and b = [x2:y2:z2]
	// by [u1:s1:z1z2] and [u2:s2:z1z2]
	// where u1 = x1z2, s1 = y1z2 and u1 = x2z1, s2 = y2z1
	z12, z22 := &gfP{}, &gfP{}
	gfpMul(z12, &a.z, &a.z)
	gfpMul(z22, &b.z, &b.z)

	u1, u2 := &gfP{}, &gfP{}
	gfpMul(u1, &a.x, z22)
	gfpMul(u2, &b.x, z12)

	t, s1 := &gfP{}, &gfP{}
	gfpMul(t, &b.z, z22)
	gfpMul(s1, &a.y, t)

	s2 := &gfP{}
	gfpMul(t, &a.z, z12)
	gfpMul(s2, &b.y, t)

	// Compute x = (2h)(s-u1-u2)
	// where s = (s2-s1)/(u2-u1) is the slope of the line through
	// (u1,s1) and (u2,s2). The extra factor 2h = 2(u2-u1) comes from the value of z below.
	// This is also:
	// 4(s2-s1) - 4h(u1+u2) = 4(s2-s1) - 4h - 4h(2u1)
	//                        = r - j - 2v
	// with the notations below.
	h := &gfP{}
	gfpSub(h, u2, u1)
	xEqual := *h == gfP{0}

	gfpAdd(t, h, h)
	// i = 4h
	i := &gfP{}
	gfpMul(i, t, t)
	// j = 4h
	j := &gfP{}
	gfpMul(j, h, i)

	gfpSub(t, s2, s1)
	yEqual := *t == gfP{0}
	if xEqual && yEqual {
		c.Double(a)
		return
	}
	r := &gfP{}
	gfpAdd(r, t, t)

	v := &gfP{}
	gfpMul(v, u1, i)

	// t4 = 4(s2-s1)
	t4, t6 := &gfP{}, &gfP{}
	gfpMul(t4, r, r)
	gfpAdd(t, v, v)
	gfpSub(t6, t4, j)

	gfpSub(&c.x, t6, t)

	// Set y = -(2h)(s1 + s*(x/4h-u1))
	// This is also
	// y = - 2s1j - (s2-s1)(2x - 2iu1) = r(v-x) - 2s1j
	gfpSub(t, v, &c.x) // t7
	gfpMul(t4, s1, j)  // t8
	gfpAdd(t6, t4, t4) // t9
	gfpMul(t4, r, t)   // t10
	gfpSub(&c.y, t4, t6)

	// Set z = 2(u2-u1)z1z2 = 2hz1z2
	gfpAdd(t, &a.z, &b.z) // t11
	gfpMul(t4, t, t)      // t12
	gfpSub(t, t4, z12)    // t13
	gfpSub(t4, t, z22)    // t14
	gfpMul(&c.z, t4, h)
}

func (c *curvePoint) Double(a *curvePoint) {
	// See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/doubling/dbl-2009-l.op3
	A, B, C := &gfP{}, &gfP{}, &gfP{}
	gfpMul(A, &a.x, &a.x)
	gfpMul(B, &a.y, &a.y)
	gfpMul(C, B, B)

	t, t2 := &gfP{}, &gfP{}
	gfpAdd(t, &a.x, B)
	gfpMul(t2, t, t)
	gfpSub(t, t2, A)
	gfpSub(t2, t, C)

	d, e, f := &gfP{}, &gfP{}, &gfP{}
	gfpAdd(d, t2, t2)
	gfpAdd(t, A, A)
	gfpAdd(e, t, A)
	gfpMul(f, e, e)

	gfpAdd(t, d, d)
	gfpSub(&c.x, f, t)

	gfpMul(&c.z, &a.y, &a.z)
	gfpAdd(&c.z, &c.z, &c.z)

	gfpAdd(t, C, C)
	gfpAdd(t2, t, t)
	gfpAdd(t, t2, t2)
	gfpSub(&c.y, d, &c.x)
	gfpMul(t2, e, &c.y)
	gfpSub(&c.y, t2, t)
}

func (c *curvePoint) Mul(a *curvePoint, scalar *big.Int) {
	sum, t := &curvePoint{}, &curvePoint{}
	sum.SetInfinity()

	for i := scalar.BitLen(); i >= 0; i-- {
		t.Double(sum)
		if scalar.Bit(i) != 0 {
			sum.Add(t, a)
		} else {
			sum.Set(t)
		}
	}

	c.Set(sum)
}

func (c *curvePoint) MakeAffine() {
	if c.z == *newGFp(1) {
		return
	} else if c.z == *newGFp(0) {
		c.x = gfP{0}
		c.y = *newGFp(1)
		c.t = gfP{0}
		return
	}

	zInv := &gfP{}
	zInv.Invert(&c.z)

	t, zInv2 := &gfP{}, &gfP{}
	gfpMul(t, &c.y, zInv)
	gfpMul(zInv2, zInv, zInv)

	gfpMul(&c.x, &c.x, zInv2)
	gfpMul(&c.y, t, zInv2)

	c.z = *newGFp(1)
	c.t = *newGFp(1)
}

func (c *curvePoint) Neg(a *curvePoint) {
	c.x.Set(&a.x)
	gfpNeg(&c.y, &a.y)
	c.z.Set(&a.z)
	c.t = gfP{0}
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/hash.go
File Name: hash.go

===========================================

package bn256

// HashG1 implements a hashing function into the G1 group.
//
// dst represents domain separation tag, similar to salt, for the hash.
func HashG1(msg, dst []byte) *G1 {
	return mapToCurve(hashToBase(msg, dst))
}

func mapToCurve(t *gfP) *G1 {
	one := *newGFp(1)

	// calculate w = (s * t)/(1 + B + t^2)
	// we calculate w0 = s * t * (1 + B + t^2) and inverse of it, so that w = (st)^2/w0
	// and then later x3 = 1 + (1 + B + t^2)^4/w0^2
	w := &gfP{}

	// a = (1 + B + t^2)
	a := &gfP{}
	t2 := &gfP{}
	gfpMul(t2, t, t)
	gfpAdd(a, curveB, t2)
	gfpAdd(a, a, &one)

	st := &gfP{}
	gfpMul(st, s, t)

	w0 := &gfP{}
	gfpMul(w0, st, a)
	w0.Invert(w0)

	gfpMul(w, st, st)
	gfpMul(w, w, w0)

	e := sign0(t)
	cp := &curvePoint{z: one, t: one}

	// calculate x1 = ((-1 + s) / 2) - t * w
	tw := &gfP{}
	gfpMul(tw, t, w)
	x1 := &gfP{}
	gfpSub(x1, sMinus1Over2, tw)

	// check if y=x1^3+3 is a square
	y := &gfP{}
	y.Set(x1)
	gfpMul(y, x1, x1)
	gfpMul(y, y, x1)
	gfpAdd(y, y, curveB)
	if legendre(y) == 1 {
		cp.x = *x1
		y.Sqrt(y)
		if e != sign0(y) {
			gfpNeg(y, y)
		}
		cp.y = *y
		return &G1{cp}
	}

	// calculate x2 = -1 - x1
	x2 := newGFp(-1)
	gfpSub(x2, x2, x1)

	// check if y=x2^3+3 is a square
	y.Set(x2)
	gfpMul(y, x2, x2)
	gfpMul(y, y, x2)
	gfpAdd(y, y, curveB)
	if legendre(y) == 1 {
		cp.x = *x2
		y.Sqrt(y)
		if e != sign0(y) {
			gfpNeg(y, y)
		}
		cp.y = *y
		return &G1{cp}
	}

	// calculate x3 = 1 + (1/ww) = 1 + a^4 * w0^2
	x3 := &gfP{}
	gfpMul(x3, a, a)
	gfpMul(x3, x3, x3)
	gfpMul(x3, x3, w0)
	gfpMul(x3, x3, w0)
	gfpAdd(x3, x3, &one)

	y.Set(x3)
	gfpMul(y, x3, x3)
	gfpMul(y, y, x3)
	gfpAdd(y, y, curveB)

	cp.x = *x3
	y.Sqrt(y)
	if e != sign0(y) {
		gfpNeg(y, y)
	}
	cp.y = *y

	return &G1{cp}
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/gfp2.go
File Name: gfp2.go

===========================================

package bn256

// For details of the algorithms used, see "Multiplication and Squaring on
// Pairing-Friendly Fields, Devegili et al.
// http://eprint.iacr.org/2006/471.pdf.

// gfP2 implements a field of size p as a quadratic extension of the base field
// where i=-1.
type gfP2 struct {
	x, y gfP // value is xi+y.
}

func gfP2Decode(in *gfP2) *gfP2 {
	out := &gfP2{}
	montDecode(&out.x, &in.x)
	montDecode(&out.y, &in.y)
	return out
}

func (e *gfP2) String() string {
	return "(" + e.x.String() + ", " + e.y.String() + ")"
}

func (e *gfP2) Set(a *gfP2) *gfP2 {
	e.x.Set(&a.x)
	e.y.Set(&a.y)
	return e
}

func (e *gfP2) SetZero() *gfP2 {
	e.x = gfP{0}
	e.y = gfP{0}
	return e
}

func (e *gfP2) SetOne() *gfP2 {
	e.x = gfP{0}
	e.y = *newGFp(1)
	return e
}

func (e *gfP2) IsZero() bool {
	zero := gfP{0}
	return e.x == zero && e.y == zero
}

func (e *gfP2) IsOne() bool {
	zero, one := gfP{0}, *newGFp(1)
	return e.x == zero && e.y == one
}

func (e *gfP2) Conjugate(a *gfP2) *gfP2 {
	e.y.Set(&a.y)
	gfpNeg(&e.x, &a.x)
	return e
}

func (e *gfP2) Neg(a *gfP2) *gfP2 {
	gfpNeg(&e.x, &a.x)
	gfpNeg(&e.y, &a.y)
	return e
}

func (e *gfP2) Add(a, b *gfP2) *gfP2 {
	gfpAdd(&e.x, &a.x, &b.x)
	gfpAdd(&e.y, &a.y, &b.y)
	return e
}

func (e *gfP2) Sub(a, b *gfP2) *gfP2 {
	gfpSub(&e.x, &a.x, &b.x)
	gfpSub(&e.y, &a.y, &b.y)
	return e
}

// See "Multiplication and Squaring in Pairing-Friendly Fields",
// http://eprint.iacr.org/2006/471.pdf
func (e *gfP2) Mul(a, b *gfP2) *gfP2 {
	tx, t := &gfP{}, &gfP{}
	gfpMul(tx, &a.x, &b.y)
	gfpMul(t, &b.x, &a.y)
	gfpAdd(tx, tx, t)

	ty := &gfP{}
	gfpMul(ty, &a.y, &b.y)
	gfpMul(t, &a.x, &b.x)
	gfpSub(ty, ty, t)

	e.x.Set(tx)
	e.y.Set(ty)
	return e
}

func (e *gfP2) MulScalar(a *gfP2, b *gfP) *gfP2 {
	gfpMul(&e.x, &a.x, b)
	gfpMul(&e.y, &a.y, b)
	return e
}

// MulXi sets e=a where =i+3 and then returns e.
func (e *gfP2) MulXi(a *gfP2) *gfP2 {
	// (xi+y)(i+3) = (3x+y)i+(3y-x)
	tx := &gfP{}
	gfpAdd(tx, &a.x, &a.x)
	gfpAdd(tx, tx, &a.x)
	gfpAdd(tx, tx, &a.y)

	ty := &gfP{}
	gfpAdd(ty, &a.y, &a.y)
	gfpAdd(ty, ty, &a.y)
	gfpSub(ty, ty, &a.x)

	e.x.Set(tx)
	e.y.Set(ty)
	return e
}

func (e *gfP2) Square(a *gfP2) *gfP2 {
	// Complex squaring algorithm:
	// (xi+y) = (x+y)(y-x) + 2*i*x*y
	tx, ty := &gfP{}, &gfP{}
	gfpSub(tx, &a.y, &a.x)
	gfpAdd(ty, &a.x, &a.y)
	gfpMul(ty, tx, ty)

	gfpMul(tx, &a.x, &a.y)
	gfpAdd(tx, tx, tx)

	e.x.Set(tx)
	e.y.Set(ty)
	return e
}

func (e *gfP2) Invert(a *gfP2) *gfP2 {
	// See "Implementing cryptographic pairings", M. Scott, section 3.2.
	// ftp://136.206.11.249/pub/crypto/pairings.pdf
	t1, t2 := &gfP{}, &gfP{}
	gfpMul(t1, &a.x, &a.x)
	gfpMul(t2, &a.y, &a.y)
	gfpAdd(t1, t1, t2)

	inv := &gfP{}
	inv.Invert(t1)

	gfpNeg(t1, &a.x)

	gfpMul(&e.x, t1, inv)
	gfpMul(&e.y, &a.y, inv)
	return e
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/gfp.go
File Name: gfp.go

===========================================

package bn256

import (
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"math/big"

	"golang.org/x/crypto/hkdf"
)

type gfP [4]uint64

func newGFp(x int64) (out *gfP) {
	if x >= 0 {
		out = &gfP{uint64(x)}
	} else {
		out = &gfP{uint64(-x)}
		gfpNeg(out, out)
	}

	montEncode(out, out)
	return out
}

// hashToBase implements hashing a message to an element of the field.
//
// L = ceil((256+128)/8)=48, ctr = 0, i = 1
func hashToBase(msg, dst []byte) *gfP {
	var t [48]byte
	info := []byte{'H', '2', 'C', byte(0), byte(1)}
	r := hkdf.New(sha256.New, msg, dst, info)
	if _, err := r.Read(t[:]); err != nil {
		panic(err)
	}
	var x big.Int
	v := x.SetBytes(t[:]).Mod(&x, p).Bytes()
	v32 := [32]byte{}
	for i := len(v) - 1; i >= 0; i-- {
		v32[len(v)-1-i] = v[i]
	}
	u := &gfP{
		binary.LittleEndian.Uint64(v32[0*8 : 1*8]),
		binary.LittleEndian.Uint64(v32[1*8 : 2*8]),
		binary.LittleEndian.Uint64(v32[2*8 : 3*8]),
		binary.LittleEndian.Uint64(v32[3*8 : 4*8]),
	}
	montEncode(u, u)
	return u
}

func (e *gfP) String() string {
	return fmt.Sprintf("%16.16x%16.16x%16.16x%16.16x", e[3], e[2], e[1], e[0])
}

func (e *gfP) Set(f *gfP) {
	e[0] = f[0]
	e[1] = f[1]
	e[2] = f[2]
	e[3] = f[3]
}

func (e *gfP) exp(f *gfP, bits [4]uint64) {
	sum, power := &gfP{}, &gfP{}
	sum.Set(rN1)
	power.Set(f)

	for word := 0; word < 4; word++ {
		for bit := uint(0); bit < 64; bit++ {
			if (bits[word]>>bit)&1 == 1 {
				gfpMul(sum, sum, power)
			}
			gfpMul(power, power, power)
		}
	}

	gfpMul(sum, sum, r3)
	e.Set(sum)
}

func (e *gfP) Invert(f *gfP) {
	e.exp(f, pMinus2)
}

func (e *gfP) Sqrt(f *gfP) {
	// Since p = 4k+3, then e = f^(k+1) is a root of f.
	e.exp(f, pPlus1Over4)
}

func (e *gfP) Marshal(out []byte) {
	for w := uint(0); w < 4; w++ {
		for b := uint(0); b < 8; b++ {
			out[8*w+b] = byte(e[3-w] >> (56 - 8*b))
		}
	}
}

func (e *gfP) Unmarshal(in []byte) {
	for w := uint(0); w < 4; w++ {
		e[3-w] = 0
		for b := uint(0); b < 8; b++ {
			e[3-w] += uint64(in[8*w+b]) << (56 - 8*b)
		}
	}
}

func montEncode(c, a *gfP) { gfpMul(c, a, r2) }
func montDecode(c, a *gfP) { gfpMul(c, a, &gfP{1}) }

func sign0(e *gfP) int {
	x := &gfP{}
	montDecode(x, e)
	for w := 3; w >= 0; w-- {
		if x[w] > pMinus1Over2[w] {
			return 1
		} else if x[w] < pMinus1Over2[w] {
			return -1
		}
	}
	return 1
}

func legendre(e *gfP) int {
	f := &gfP{}
	// Since p = 4k+3, then e^(2k+1) is the Legendre symbol of e.
	f.exp(e, pMinus1Over2)

	montDecode(f, f)

	if *f != [4]uint64{} {
		return 2*int(f[0]&1) - 1
	}

	return 0
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/gfp6.go
File Name: gfp6.go

===========================================

package bn256

// For details of the algorithms used, see "Multiplication and Squaring on
// Pairing-Friendly Fields, Devegili et al.
// http://eprint.iacr.org/2006/471.pdf.

// gfP6 implements the field of size p as a cubic extension of gfP2 where =
// and =i+3.
type gfP6 struct {
	x, y, z gfP2 // value is x + y + z
}

func (e *gfP6) String() string {
	return "(" + e.x.String() + ", " + e.y.String() + ", " + e.z.String() + ")"
}

func (e *gfP6) Set(a *gfP6) *gfP6 {
	e.x.Set(&a.x)
	e.y.Set(&a.y)
	e.z.Set(&a.z)
	return e
}

func (e *gfP6) SetZero() *gfP6 {
	e.x.SetZero()
	e.y.SetZero()
	e.z.SetZero()
	return e
}

func (e *gfP6) SetOne() *gfP6 {
	e.x.SetZero()
	e.y.SetZero()
	e.z.SetOne()
	return e
}

func (e *gfP6) IsZero() bool {
	return e.x.IsZero() && e.y.IsZero() && e.z.IsZero()
}

func (e *gfP6) IsOne() bool {
	return e.x.IsZero() && e.y.IsZero() && e.z.IsOne()
}

func (e *gfP6) Neg(a *gfP6) *gfP6 {
	e.x.Neg(&a.x)
	e.y.Neg(&a.y)
	e.z.Neg(&a.z)
	return e
}

func (e *gfP6) Frobenius(a *gfP6) *gfP6 {
	e.x.Conjugate(&a.x)
	e.y.Conjugate(&a.y)
	e.z.Conjugate(&a.z)

	e.x.Mul(&e.x, xiTo2PMinus2Over3)
	e.y.Mul(&e.y, xiToPMinus1Over3)
	return e
}

// FrobeniusP2 computes (x+y+z)^(p) = x^(2p) + y^(p) + z
func (e *gfP6) FrobeniusP2(a *gfP6) *gfP6 {
	// ^(2p) = ^(2p-2) = ^((2p-2)/3)
	e.x.MulScalar(&a.x, xiTo2PSquaredMinus2Over3)
	// ^(p) = ^(p-1) = ^((p-1)/3)
	e.y.MulScalar(&a.y, xiToPSquaredMinus1Over3)
	e.z.Set(&a.z)
	return e
}

func (e *gfP6) FrobeniusP4(a *gfP6) *gfP6 {
	e.x.MulScalar(&a.x, xiToPSquaredMinus1Over3)
	e.y.MulScalar(&a.y, xiTo2PSquaredMinus2Over3)
	e.z.Set(&a.z)
	return e
}

func (e *gfP6) Add(a, b *gfP6) *gfP6 {
	e.x.Add(&a.x, &b.x)
	e.y.Add(&a.y, &b.y)
	e.z.Add(&a.z, &b.z)
	return e
}

func (e *gfP6) Sub(a, b *gfP6) *gfP6 {
	e.x.Sub(&a.x, &b.x)
	e.y.Sub(&a.y, &b.y)
	e.z.Sub(&a.z, &b.z)
	return e
}

func (e *gfP6) Mul(a, b *gfP6) *gfP6 {
	// "Multiplication and Squaring on Pairing-Friendly Fields"
	// Section 4, Karatsuba method.
	// http://eprint.iacr.org/2006/471.pdf
	v0 := (&gfP2{}).Mul(&a.z, &b.z)
	v1 := (&gfP2{}).Mul(&a.y, &b.y)
	v2 := (&gfP2{}).Mul(&a.x, &b.x)

	t0 := (&gfP2{}).Add(&a.x, &a.y)
	t1 := (&gfP2{}).Add(&b.x, &b.y)
	tz := (&gfP2{}).Mul(t0, t1)
	tz.Sub(tz, v1).Sub(tz, v2).MulXi(tz).Add(tz, v0)

	t0.Add(&a.y, &a.z)
	t1.Add(&b.y, &b.z)
	ty := (&gfP2{}).Mul(t0, t1)
	t0.MulXi(v2)
	ty.Sub(ty, v0).Sub(ty, v1).Add(ty, t0)

	t0.Add(&a.x, &a.z)
	t1.Add(&b.x, &b.z)
	tx := (&gfP2{}).Mul(t0, t1)
	tx.Sub(tx, v0).Add(tx, v1).Sub(tx, v2)

	e.x.Set(tx)
	e.y.Set(ty)
	e.z.Set(tz)
	return e
}

func (e *gfP6) MulScalar(a *gfP6, b *gfP2) *gfP6 {
	e.x.Mul(&a.x, b)
	e.y.Mul(&a.y, b)
	e.z.Mul(&a.z, b)
	return e
}

func (e *gfP6) MulGFP(a *gfP6, b *gfP) *gfP6 {
	e.x.MulScalar(&a.x, b)
	e.y.MulScalar(&a.y, b)
	e.z.MulScalar(&a.z, b)
	return e
}

// MulTau computes (a+b+c) = b+c+a
func (e *gfP6) MulTau(a *gfP6) *gfP6 {
	tz := (&gfP2{}).MulXi(&a.x)
	ty := (&gfP2{}).Set(&a.y)

	e.y.Set(&a.z)
	e.x.Set(ty)
	e.z.Set(tz)
	return e
}

func (e *gfP6) Square(a *gfP6) *gfP6 {
	v0 := (&gfP2{}).Square(&a.z)
	v1 := (&gfP2{}).Square(&a.y)
	v2 := (&gfP2{}).Square(&a.x)

	c0 := (&gfP2{}).Add(&a.x, &a.y)
	c0.Square(c0).Sub(c0, v1).Sub(c0, v2).MulXi(c0).Add(c0, v0)

	c1 := (&gfP2{}).Add(&a.y, &a.z)
	c1.Square(c1).Sub(c1, v0).Sub(c1, v1)
	xiV2 := (&gfP2{}).MulXi(v2)
	c1.Add(c1, xiV2)

	c2 := (&gfP2{}).Add(&a.x, &a.z)
	c2.Square(c2).Sub(c2, v0).Add(c2, v1).Sub(c2, v2)

	e.x.Set(c2)
	e.y.Set(c1)
	e.z.Set(c0)
	return e
}

func (e *gfP6) Invert(a *gfP6) *gfP6 {
	// See "Implementing cryptographic pairings", M. Scott, section 3.2.
	// ftp://136.206.11.249/pub/crypto/pairings.pdf

	// Here we can give a short explanation of how it works: let j be a cubic root of
	// unity in GF(p) so that 1+j+j=0.
	// Then (x + y + z)(xj + yj + z)(xj + yj + z)
	// = (x + y + z)(C+B+A)
	// = (x+y+z-3xyz) = F is an element of the base field (the norm).
	//
	// On the other hand (xj + yj + z)(xj + yj + z)
	// = (y-xz) + (x-yz) + (z-xy)
	//
	// So that's why A = (z-xy), B = (x-yz), C = (y-xz)
	t1 := (&gfP2{}).Mul(&a.x, &a.y)
	t1.MulXi(t1)

	A := (&gfP2{}).Square(&a.z)
	A.Sub(A, t1)

	B := (&gfP2{}).Square(&a.x)
	B.MulXi(B)
	t1.Mul(&a.y, &a.z)
	B.Sub(B, t1)

	C := (&gfP2{}).Square(&a.y)
	t1.Mul(&a.x, &a.z)
	C.Sub(C, t1)

	F := (&gfP2{}).Mul(C, &a.y)
	F.MulXi(F)
	t1.Mul(A, &a.z)
	F.Add(F, t1)
	t1.Mul(B, &a.x).MulXi(t1)
	F.Add(F, t1)

	F.Invert(F)

	e.x.Mul(C, F)
	e.y.Mul(B, F)
	e.z.Mul(A, F)
	return e
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/bn256.go
File Name: bn256.go

===========================================

// Package bn256 implements a particular bilinear group.
//
// Bilinear groups are the basis of many of the new cryptographic protocols that
// have been proposed over the past decade. They consist of a triplet of groups
// (G, G and GT) such that there exists a function e(g,g)=gT (where g
// is a generator of the respective group). That function is called a pairing
// function.
//
// This package specifically implements the Optimal Ate pairing over a 256-bit
// Barreto-Naehrig curve as described in
// http://cryptojedi.org/papers/dclxvi-20100714.pdf. Its output is compatible
// with the implementation described in that paper.
//
// This package previously claimed to operate at a 128-bit security level.
// However, recent improvements in attacks mean that is no longer true. See
// https://moderncrypto.org/mail-archive/curves/2016/000740.html.
package bn256

import (
	"crypto/rand"
	"errors"
	"io"
	"math/big"
)

func randomK(r io.Reader) (k *big.Int, err error) {
	for {
		k, err = rand.Int(r, Order)
		if err != nil || k.Sign() > 0 {
			return
		}
	}

	return
}

// G1 is an abstract cyclic group. The zero value is suitable for use as the
// output of an operation, but cannot be used as an input.
type G1 struct {
	p *curvePoint
}

// RandomG1 returns x and g where x is a random, non-zero number read from r.
func RandomG1(r io.Reader) (*big.Int, *G1, error) {
	k, err := randomK(r)
	if err != nil {
		return nil, nil, err
	}

	return k, new(G1).ScalarBaseMult(k), nil
}

func (g *G1) String() string {
	return "bn256.G1" + g.p.String()
}

// ScalarBaseMult sets e to g*k where g is the generator of the group and then
// returns e.
func (e *G1) ScalarBaseMult(k *big.Int) *G1 {
	if e.p == nil {
		e.p = &curvePoint{}
	}
	e.p.Mul(curveGen, k)
	return e
}

// ScalarMult sets e to a*k and then returns e.
func (e *G1) ScalarMult(a *G1, k *big.Int) *G1 {
	if e.p == nil {
		e.p = &curvePoint{}
	}
	e.p.Mul(a.p, k)
	return e
}

// Add sets e to a+b and then returns e.
func (e *G1) Add(a, b *G1) *G1 {
	if e.p == nil {
		e.p = &curvePoint{}
	}
	e.p.Add(a.p, b.p)
	return e
}

// Neg sets e to -a and then returns e.
func (e *G1) Neg(a *G1) *G1 {
	if e.p == nil {
		e.p = &curvePoint{}
	}
	e.p.Neg(a.p)
	return e
}

// Set sets e to a and then returns e.
func (e *G1) Set(a *G1) *G1 {
	if e.p == nil {
		e.p = &curvePoint{}
	}
	e.p.Set(a.p)
	return e
}

// Marshal converts e to a byte slice.
func (e *G1) Marshal() []byte {
	// Each value is a 256-bit number.
	const numBytes = 256 / 8

	if e.p == nil {
		e.p = &curvePoint{}
	}

	e.p.MakeAffine()
	ret := make([]byte, numBytes*2)
	if e.p.IsInfinity() {
		return ret
	}
	temp := &gfP{}

	montDecode(temp, &e.p.x)
	temp.Marshal(ret)
	montDecode(temp, &e.p.y)
	temp.Marshal(ret[numBytes:])

	return ret
}

// Unmarshal sets e to the result of converting the output of Marshal back into
// a group element and then returns e.
func (e *G1) Unmarshal(m []byte) ([]byte, error) {
	// Each value is a 256-bit number.
	const numBytes = 256 / 8

	if len(m) < 2*numBytes {
		return nil, errors.New("bn256: not enough data")
	}

	if e.p == nil {
		e.p = &curvePoint{}
	} else {
		e.p.x, e.p.y = gfP{0}, gfP{0}
	}

	e.p.x.Unmarshal(m)
	e.p.y.Unmarshal(m[numBytes:])
	montEncode(&e.p.x, &e.p.x)
	montEncode(&e.p.y, &e.p.y)

	zero := gfP{0}
	if e.p.x == zero && e.p.y == zero {
		// This is the point at infinity.
		e.p.y = *newGFp(1)
		e.p.z = gfP{0}
		e.p.t = gfP{0}
	} else {
		e.p.z = *newGFp(1)
		e.p.t = *newGFp(1)

		if !e.p.IsOnCurve() {
			return nil, errors.New("bn256: malformed point")
		}
	}

	return m[2*numBytes:], nil
}

// G2 is an abstract cyclic group. The zero value is suitable for use as the
// output of an operation, but cannot be used as an input.
type G2 struct {
	p *twistPoint
}

// RandomG2 returns x and g where x is a random, non-zero number read from r.
func RandomG2(r io.Reader) (*big.Int, *G2, error) {
	k, err := randomK(r)
	if err != nil {
		return nil, nil, err
	}

	return k, new(G2).ScalarBaseMult(k), nil
}

func (e *G2) String() string {
	return "bn256.G2" + e.p.String()
}

// ScalarBaseMult sets e to g*k where g is the generator of the group and then
// returns out.
func (e *G2) ScalarBaseMult(k *big.Int) *G2 {
	if e.p == nil {
		e.p = &twistPoint{}
	}
	e.p.Mul(twistGen, k)
	return e
}

// ScalarMult sets e to a*k and then returns e.
func (e *G2) ScalarMult(a *G2, k *big.Int) *G2 {
	if e.p == nil {
		e.p = &twistPoint{}
	}
	e.p.Mul(a.p, k)
	return e
}

// Add sets e to a+b and then returns e.
func (e *G2) Add(a, b *G2) *G2 {
	if e.p == nil {
		e.p = &twistPoint{}
	}
	e.p.Add(a.p, b.p)
	return e
}

// Neg sets e to -a and then returns e.
func (e *G2) Neg(a *G2) *G2 {
	if e.p == nil {
		e.p = &twistPoint{}
	}
	e.p.Neg(a.p)
	return e
}

// Set sets e to a and then returns e.
func (e *G2) Set(a *G2) *G2 {
	if e.p == nil {
		e.p = &twistPoint{}
	}
	e.p.Set(a.p)
	return e
}

// Marshal converts e into a byte slice.
func (e *G2) Marshal() []byte {
	// Each value is a 256-bit number.
	const numBytes = 256 / 8

	if e.p == nil {
		e.p = &twistPoint{}
	}

	e.p.MakeAffine()
	if e.p.IsInfinity() {
		return make([]byte, 1)
	}

	ret := make([]byte, 1+numBytes*4)
	ret[0] = 0x01
	temp := &gfP{}

	montDecode(temp, &e.p.x.x)
	temp.Marshal(ret[1:])
	montDecode(temp, &e.p.x.y)
	temp.Marshal(ret[1+numBytes:])
	montDecode(temp, &e.p.y.x)
	temp.Marshal(ret[1+2*numBytes:])
	montDecode(temp, &e.p.y.y)
	temp.Marshal(ret[1+3*numBytes:])

	return ret
}

// Unmarshal sets e to the result of converting the output of Marshal back into
// a group element and then returns e.
func (e *G2) Unmarshal(m []byte) ([]byte, error) {
	// Each value is a 256-bit number.
	const numBytes = 256 / 8

	if e.p == nil {
		e.p = &twistPoint{}
	}

	if len(m) > 0 && m[0] == 0x00 {
		e.p.SetInfinity()
		return m[1:], nil
	} else if len(m) > 0 && m[0] != 0x01 {
		return nil, errors.New("bn256: malformed point")
	} else if len(m) < 1+4*numBytes {
		return nil, errors.New("bn256: not enough data")
	}

	e.p.x.x.Unmarshal(m[1:])
	e.p.x.y.Unmarshal(m[1+numBytes:])
	e.p.y.x.Unmarshal(m[1+2*numBytes:])
	e.p.y.y.Unmarshal(m[1+3*numBytes:])
	montEncode(&e.p.x.x, &e.p.x.x)
	montEncode(&e.p.x.y, &e.p.x.y)
	montEncode(&e.p.y.x, &e.p.y.x)
	montEncode(&e.p.y.y, &e.p.y.y)

	if e.p.x.IsZero() && e.p.y.IsZero() {
		// This is the point at infinity.
		e.p.y.SetOne()
		e.p.z.SetZero()
		e.p.t.SetZero()
	} else {
		e.p.z.SetOne()
		e.p.t.SetOne()

		if !e.p.IsOnCurve() {
			return nil, errors.New("bn256: malformed point")
		}
	}

	return m[1+4*numBytes:], nil
}

// GT is an abstract cyclic group. The zero value is suitable for use as the
// output of an operation, but cannot be used as an input.
type GT struct {
	p *gfP12
}

// RandomGT returns x and e(g, g) where x is a random, non-zero number read
// from r.
func RandomGT(r io.Reader) (*big.Int, *GT, error) {
	k, err := randomK(r)
	if err != nil {
		return nil, nil, err
	}

	return k, new(GT).ScalarBaseMult(k), nil
}

// Pair calculates an Optimal Ate pairing.
func Pair(g1 *G1, g2 *G2) *GT {
	return &GT{optimalAte(g2.p, g1.p)}
}

// Miller applies Miller's algorithm, which is a bilinear function from the
// source groups to F_p^12. Miller(g1, g2).Finalize() is equivalent to Pair(g1,
// g2).
func Miller(g1 *G1, g2 *G2) *GT {
	return &GT{miller(g2.p, g1.p)}
}

func (g *GT) String() string {
	return "bn256.GT" + g.p.String()
}

// ScalarBaseMult sets e to g*k where g is the generator of the group and then
// returns out.
func (e *GT) ScalarBaseMult(k *big.Int) *GT {
	if e.p == nil {
		e.p = &gfP12{}
	}
	e.p.Exp(gfP12Gen, k)
	return e
}

// ScalarMult sets e to a*k and then returns e.
func (e *GT) ScalarMult(a *GT, k *big.Int) *GT {
	if e.p == nil {
		e.p = &gfP12{}
	}
	e.p.Exp(a.p, k)
	return e
}

// Add sets e to a+b and then returns e.
func (e *GT) Add(a, b *GT) *GT {
	if e.p == nil {
		e.p = &gfP12{}
	}
	e.p.Mul(a.p, b.p)
	return e
}

// Neg sets e to -a and then returns e.
func (e *GT) Neg(a *GT) *GT {
	if e.p == nil {
		e.p = &gfP12{}
	}
	e.p.Conjugate(a.p)
	return e
}

// Set sets e to a and then returns e.
func (e *GT) Set(a *GT) *GT {
	if e.p == nil {
		e.p = &gfP12{}
	}
	e.p.Set(a.p)
	return e
}

// Finalize is a linear function from F_p^12 to GT.
func (e *GT) Finalize() *GT {
	ret := finalExponentiation(e.p)
	e.p.Set(ret)
	return e
}

// Marshal converts e into a byte slice.
func (e *GT) Marshal() []byte {
	// Each value is a 256-bit number.
	const numBytes = 256 / 8

	if e.p == nil {
		e.p = &gfP12{}
		e.p.SetOne()
	}

	ret := make([]byte, numBytes*12)
	temp := &gfP{}

	montDecode(temp, &e.p.x.x.x)
	temp.Marshal(ret)
	montDecode(temp, &e.p.x.x.y)
	temp.Marshal(ret[numBytes:])
	montDecode(temp, &e.p.x.y.x)
	temp.Marshal(ret[2*numBytes:])
	montDecode(temp, &e.p.x.y.y)
	temp.Marshal(ret[3*numBytes:])
	montDecode(temp, &e.p.x.z.x)
	temp.Marshal(ret[4*numBytes:])
	montDecode(temp, &e.p.x.z.y)
	temp.Marshal(ret[5*numBytes:])
	montDecode(temp, &e.p.y.x.x)
	temp.Marshal(ret[6*numBytes:])
	montDecode(temp, &e.p.y.x.y)
	temp.Marshal(ret[7*numBytes:])
	montDecode(temp, &e.p.y.y.x)
	temp.Marshal(ret[8*numBytes:])
	montDecode(temp, &e.p.y.y.y)
	temp.Marshal(ret[9*numBytes:])
	montDecode(temp, &e.p.y.z.x)
	temp.Marshal(ret[10*numBytes:])
	montDecode(temp, &e.p.y.z.y)
	temp.Marshal(ret[11*numBytes:])

	return ret
}

// Unmarshal sets e to the result of converting the output of Marshal back into
// a group element and then returns e.
func (e *GT) Unmarshal(m []byte) ([]byte, error) {
	// Each value is a 256-bit number.
	const numBytes = 256 / 8

	if len(m) < 12*numBytes {
		return nil, errors.New("bn256: not enough data")
	}

	if e.p == nil {
		e.p = &gfP12{}
	}

	e.p.x.x.x.Unmarshal(m)
	e.p.x.x.y.Unmarshal(m[numBytes:])
	e.p.x.y.x.Unmarshal(m[2*numBytes:])
	e.p.x.y.y.Unmarshal(m[3*numBytes:])
	e.p.x.z.x.Unmarshal(m[4*numBytes:])
	e.p.x.z.y.Unmarshal(m[5*numBytes:])
	e.p.y.x.x.Unmarshal(m[6*numBytes:])
	e.p.y.x.y.Unmarshal(m[7*numBytes:])
	e.p.y.y.x.Unmarshal(m[8*numBytes:])
	e.p.y.y.y.Unmarshal(m[9*numBytes:])
	e.p.y.z.x.Unmarshal(m[10*numBytes:])
	e.p.y.z.y.Unmarshal(m[11*numBytes:])
	montEncode(&e.p.x.x.x, &e.p.x.x.x)
	montEncode(&e.p.x.x.y, &e.p.x.x.y)
	montEncode(&e.p.x.y.x, &e.p.x.y.x)
	montEncode(&e.p.x.y.y, &e.p.x.y.y)
	montEncode(&e.p.x.z.x, &e.p.x.z.x)
	montEncode(&e.p.x.z.y, &e.p.x.z.y)
	montEncode(&e.p.y.x.x, &e.p.y.x.x)
	montEncode(&e.p.y.x.y, &e.p.y.x.y)
	montEncode(&e.p.y.y.x, &e.p.y.y.x)
	montEncode(&e.p.y.y.y, &e.p.y.y.y)
	montEncode(&e.p.y.z.x, &e.p.y.z.x)
	montEncode(&e.p.y.z.y, &e.p.y.z.y)

	return m[12*numBytes:], nil
}

===========================================

File Path: ./vendor/github.com/cloudflare/bn256/gfp12.go
File Name: gfp12.go

===========================================

package bn256

// For details of the algorithms used, see "Multiplication and Squaring on
// Pairing-Friendly Fields, Devegili et al.
// http://eprint.iacr.org/2006/471.pdf.

import (
	"math/big"
)

// gfP12 implements the field of size p as a quadratic extension of gfP6
// where =.
type gfP12 struct {
	x, y gfP6 // value is x + y
}

var gfP12Gen *gfP12 = &gfP12{
	x: gfP6{
		x: gfP2{
			x: gfP{0x62d608d6bb67a4fb, 0x9a66ec93f0c2032f, 0x5391628e924e1a34, 0x2162dbf7de801d0e},
			y: gfP{0x3e0c1a72bf08eb4f, 0x4972ec05990a5ecc, 0xf7b9a407ead8007e, 0x3ca04c613572ce49},
		},
		y: gfP2{
			x: gfP{0xace536a5607c910e, 0xda93774a941ddd40, 0x5de0e9853b7593ad, 0xe05bb926f513153},
			y: gfP{0x3f4c99f8abaf1a22, 0x66d5f6121f86dc33, 0x8e0a82f68a50abba, 0x819927d1eebd0695},
		},
		z: gfP2{
			x: gfP{0x7cdef49c5477faa, 0x40eb71ffedaa199d, 0xbc896661f17c9b8f, 0x3144462983c38c02},
			y: gfP{0xcd09ee8dd8418013, 0xf8d050d05faa9b11, 0x589e90a555507ee1, 0x58e4ab25f9c49c15},
		},
	},
	y: gfP6{
		x: gfP2{
			x: gfP{0x7e76809b142d020b, 0xd9949d1b2822e995, 0x3de93d974f84b076, 0x144523477028928d},
			y: gfP{0x79952799f9ef4b0, 0x4102c47aa3df01c6, 0xfa82a633c53da2e1, 0x54c3f0392f9f7e0e},
		},
		y: gfP2{
			x: gfP{0xd3432a335533272b, 0xa008fbbdc7d74f4a, 0x68e3c81eb7295ed9, 0x17fe34c21fdecef2},
			y: gfP{0xfb0bc4c0ef6df55f, 0x8bdc585b70bc2120, 0x17d498d2cb720def, 0x2a368248319b899c},
		},
		z: gfP2{
			x: gfP{0xf8487d81cb354c6c, 0x7421be69f1522caa, 0x6940c778b9fb2d54, 0x7da4b04e102bb621},
			y: gfP{0x97b91989993e7be4, 0x8526545356eab684, 0xb050073022eb1892, 0x658b432ad09939c0},
		},
	},
}

func (e *gfP12) String() string {
	return "(" + e.x.String() + "," + e.y.String() + ")"
}

func (e *gfP12) Set(a *gfP12) *gfP12 {
	e.x.Set(&a.x)
	e.y.Set(&a.y)
	return e
}

func (e *gfP12) SetZero() *gfP12 {
	e.x.SetZero()
	e.y.SetZero()
	return e
}

func (e *gfP12) SetOne() *gfP12 {
	e.x.SetZero()
	e.y.SetOne()
	return e
}

func (e *gfP12) IsZero() bool {
	return e.x.IsZero() && e.y.IsZero()
}

func (e *gfP12) IsOne() bool {
	return e.x.IsZero() && e.y.IsOne()
}

func (e *gfP12) Conjugate(a *gfP12) *gfP12 {
	e.x.Neg(&a.x)
	e.y.Set(&a.y)
	return e
}

func (e *gfP12) Neg(a *gfP12) *gfP12 {
	e.x.Neg(&a.x)
	e.y.Neg(&a.y)
	return e
}

// Frobenius computes (x+y)^p = x^p ^((p-1)/6) + y^p
func (e *gfP12) Frobenius(a *gfP12) *gfP12 {
	e.x.Frobenius(&a.x)
	e.y.Frobenius(&a.y)
	e.x.MulScalar(&e.x, xiToPMinus1Over6)
	return e
}

// FrobeniusP2 computes (x+y)^p = x^p ^((p-1)/6) + y^p
func (e *gfP12) FrobeniusP2(a *gfP12) *gfP12 {
	e.x.FrobeniusP2(&a.x)
	e.x.MulGFP(&e.x, xiToPSquaredMinus1Over6)
	e.y.FrobeniusP2(&a.y)
	return e
}

func (e *gfP12) FrobeniusP4(a *gfP12) *gfP12 {
	e.x.FrobeniusP4(&a.x)
	e.x.MulGFP(&e.x, xiToPSquaredMinus1Over3)
	e.y.FrobeniusP4(&a.y)
	return e
}

func (e *gfP12) Add(a, b *gfP12) *gfP12 {
	e.x.Add(&a.x, &b.x)
	e.y.Add(&a.y, &b.y)
	return e
}

func (e *gfP12) Sub(a, b *gfP12) *gfP12 {
	e.x.Sub(&a.x, &b.x)
	e.y.Sub(&a.y, &b.y)
	return e
}

func (e *gfP12) Mul(a, b *gfP12) *gfP12 {
	tx := (&gfP6{}).Mul(&a.x, &b.y)
	t := (&gfP6{}).Mul(&b.x, &a.y)
	tx.Add(tx, t)

	ty := (&gfP6{}).Mul(&a.y, &b.y)
	t.Mul(&a.x, &b.x).MulTau(t)

	e.x.Set(tx)
	e.y.Add(ty, t)
	return e
}

func (e *gfP12) MulScalar(a *gfP12, b *gfP6) *gfP12 {
	e.x.Mul(&a.x, b)
	e.y.Mul(&a.y, b)
	return e
}

func (c *gfP12) Exp(a *gfP12, power *big.Int) *gfP12 {
	sum := (&gfP12{}).SetOne()
	t := &gfP12{}

	for i := power.BitLen() - 1; i >= 0; i-- {
		t.Square(sum)
		if power.Bit(i) != 0 {
			sum.Mul(t, a)
		} else {
			sum.Set(t)
		}
	}

	c.Set(sum)
	return c
}

func (e *gfP12) Square(a *gfP12) *gfP12 {
	// Complex squaring algorithm
	v0 := (&gfP6{}).Mul(&a.x, &a.y)

	t := (&gfP6{}).MulTau(&a.x)
	t.Add(&a.y, t)
	ty := (&gfP6{}).Add(&a.x, &a.y)
	ty.Mul(ty, t).Sub(ty, v0)
	t.MulTau(v0)
	ty.Sub(ty, t)

	e.x.Add(v0, v0)
	e.y.Set(ty)
	return e
}

func (e *gfP12) Invert(a *gfP12) *gfP12 {
	// See "Implementing cryptographic pairings", M. Scott, section 3.2.
	// ftp://136.206.11.249/pub/crypto/pairings.pdf
	t1, t2 := &gfP6{}, &gfP6{}

	t1.Square(&a.x)
	t2.Square(&a.y)
	t1.MulTau(t1).Sub(t2, t1)
	t2.Invert(t1)

	e.x.Neg(&a.x)
	e.y.Set(&a.y)
	e.MulScalar(e, t2)
	return e
}

===========================================

File Path: ./vendor/github.com/mimoo/StrobeGo/strobe/keccakf_amd64.go
File Name: keccakf_amd64.go

===========================================

// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!appengine,!gccgo

package strobe

// This function is implemented in keccakf_amd64.s.

//go:noescape

func keccakF1600(a *[25]uint64, nr int)

===========================================

File Path: ./vendor/github.com/mimoo/StrobeGo/strobe/strobe.go
File Name: strobe.go

===========================================

package strobe

/***************************************************/
/*
/* This is a compact implementation of Strobe.
/* As it hasn't been thoroughly tested only use this
/* for experimental purposes :)
/*
/* Author: David Wong
/* Contact: www.cryptologie.net/contact
/*
/***************************************************/

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
)

const (
	// The size of the authentication tag used in AEAD functions
	MACLEN = 16
)

// KEY inserts a key into the state.
// It also provides forward secrecy.
func (s *Strobe) KEY(key []byte) {
	s.Operate(false, "KEY", key, 0, false)
}

// PRF provides a hash of length `output_len` of all previous operations
// It can also be used to generate random numbers, it is forward secure.
func (s *Strobe) PRF(outputLen int) []byte {
	return s.Operate(false, "PRF", []byte{}, outputLen, false)
}

// Send_ENC_unauthenticated is used to encrypt some plaintext
// it should be followed by Send_MAC in order to protect its integrity
// `meta` is used for encrypted framing data.
func (s *Strobe) Send_ENC_unauthenticated(meta bool, plaintext []byte) []byte {
	return s.Operate(meta, "send_ENC", plaintext, 0, false)
}

// Recv_ENC_unauthenticated is used to decrypt some received ciphertext
// it should be followed by Recv_MAC in order to protect its integrity
// `meta` is used for decrypting framing data.
func (s *Strobe) Recv_ENC_unauthenticated(meta bool, ciphertext []byte) []byte {
	return s.Operate(meta, "recv_ENC", ciphertext, 0, false)
}

// AD allows you to authenticate Additional Data
// it should be followed by a Send_MAC or Recv_MAC in order to truly work
func (s *Strobe) AD(meta bool, additionalData []byte) {
	s.Operate(meta, "AD", additionalData, 0, false)
}

// Send_CLR allows you to send data in cleartext
// `meta` is used to send framing data
func (s *Strobe) Send_CLR(meta bool, cleartext []byte) {
	s.Operate(meta, "send_CLR", cleartext, 0, false)
}

// Recv_CLR allows you to receive data in cleartext.
// `meta` is used to receive framing data
func (s *Strobe) Recv_CLR(meta bool, cleartext []byte) {
	s.Operate(meta, "recv_CLR", cleartext, 0, false)
}

// Send_MAC allows you to produce an authentication tag.
// `meta` is appropriate for checking the integrity of framing data.
func (s *Strobe) Send_MAC(meta bool, output_length int) []byte {
	return s.Operate(meta, "send_MAC", []byte{}, output_length, false)
}

// Recv_MAC allows you to verify a received authentication tag.
// `meta` is appropriate for checking the integrity of framing data.
func (s *Strobe) Recv_MAC(meta bool, MAC []byte) bool {
	if s.Operate(meta, "recv_MAC", MAC, 0, false)[0] == 0 {
		return true
	}
	return false
}

// RATCHET allows you to introduce forward secrecy in a protocol.
func (s *Strobe) RATCHET(length int) {
	s.Operate(false, "RATCHET", []byte{}, length, false)
}

// Send_AEAD allows you to encrypt data and authenticate additional data
// It is similar to AES-GCM.
func (s *Strobe) Send_AEAD(plaintext, ad []byte) (ciphertext []byte) {
	ciphertext = append(ciphertext, s.Send_ENC_unauthenticated(false, plaintext)...)
	s.AD(false, ad)
	ciphertext = append(ciphertext, s.Send_MAC(false, MACLEN)...)
	return
}

// Recv_AEAD allows you to decrypt data and authenticate additional data
// It is similar to AES-GCM.
func (s *Strobe) Recv_AEAD(ciphertext, ad []byte) (plaintext []byte, ok bool) {
	if len(ciphertext) < MACLEN {
		ok = false
		return
	}
	plaintext = s.Recv_ENC_unauthenticated(false, ciphertext[:len(ciphertext)-MACLEN])
	s.AD(false, ad)
	ok = s.Recv_MAC(false, ciphertext[len(ciphertext)-MACLEN:])
	return
}

//
// Strobe Objects
//

type role uint8 // for strobe.I0

const (
	iInitiator role = iota // set if we send the first transport message
	iResponder             // set if we receive the first transport message
	iNone                  // starting value
)

/*
  We do not use strobe's `pos` variable here since it is easily
  obtainable via `len(buf)`
*/
// TODO: accept permutations of different sizes
type Strobe struct {
	// config
	duplexRate int // 1600/8 - security/4
	StrobeR    int // duplexRate - 2

	// strobe specific
	initialized bool  // used to avoid padding during the first permutation
	posBegin    uint8 // start of the current operation (0 := previous block)
	I0          role

	// streaming API
	curFlags flag

	// duplex construction (see sha3.go)
	a            [25]uint64 // the actual state
	buf          []byte     // a pointer into the storage, it also serves as `pos` variable
	storage      []byte     // to-be-XORed (used for optimizations purposes)
	tempStateBuf []byte     // utility slice used for temporary duplexing operations
}

// Clone allows you to clone a Strobe state.
func (s Strobe) Clone() *Strobe {
	ret := s
	// need to recreate some buffers
	ret.storage = make([]byte, s.duplexRate)
	copy(ret.storage, s.storage)
	ret.tempStateBuf = make([]byte, s.duplexRate)
	copy(ret.tempStateBuf, s.tempStateBuf)
	// and set pointers
	ret.buf = ret.storage[:len(ret.buf)]
	return &ret
}

// Serialize allows one to serialize the strobe state to later recover it.
// [security(1)|initialized(1)|I0(1)|curFlags(1)|posBegin(1)|pos(1)|[25]uint64 state]
func (s Strobe) Serialize() []byte {
	// serialized data
	serialized := make([]byte, 6+25*8) // TODO: this is only for keccak-f[1600]
	// security?
	security := (1600/8 - s.duplexRate) * 4
	if security == 128 {
		serialized[0] = 0
	} else {
		serialized[0] = 1
	}
	// initialized?
	if s.initialized {
		serialized[1] = 1
	} else {
		serialized[1] = 0
	}
	// I0
	serialized[2] = byte(s.I0)
	// curFlags
	serialized[3] = byte(s.curFlags)
	// posBegin
	serialized[4] = byte(s.posBegin)
	// pos
	serialized[5] = byte(len(s.buf))
	// make sure to XOR what's left to XOR in the storage
	var buf [1600 / 8]byte
	var state [25]uint64
	copy(buf[:len(s.buf)], s.storage[:len(s.buf)]) // len(s.buf) = pos
	copy(state[:], s.a[:])
	xorState(&state, buf[:])
	// state
	var b []byte
	b = serialized[6:]
	for i := 0; len(b) >= 8; i++ {
		binary.LittleEndian.PutUint64(b, state[i])
		b = b[8:]
	}
	//
	return serialized
}

// Recover state allows one to re-create a strobe state from a serialized state.
// [security(1)|initialized(1)|I0(1)|curFlags(1)|posBegin(1)|pos(1)|[25]uint64 state]
func RecoverState(serialized []byte) (s Strobe) {
	if len(serialized) != 6+25*8 {
		panic("strobe: cannot recover state of invalid length")
	}
	// security?
	if serialized[0] > 1 {
		panic("strobe: cannot recover state with invalid security")
	}
	security := 128
	if security == 1 {
		security = 256
	}
	// init vars from security
	s.duplexRate = 1600/8 - security/4
	s.StrobeR = s.duplexRate - 2
	// need to recreate some buffers
	s.storage = make([]byte, s.duplexRate)
	s.tempStateBuf = make([]byte, s.duplexRate)
	// initialized?
	if serialized[1] == 1 {
		s.initialized = true
	} else {
		s.initialized = false
	}
	// I0?
	if serialized[2] > 3 {
		panic("strobe: cannot recover state with invalid role")
	}
	s.I0 = role(serialized[2])
	// curFlags + posBegin
	s.curFlags = flag(serialized[3])
	s.posBegin = uint8(serialized[4])
	// pos
	pos := int(serialized[5])
	s.buf = s.storage[:pos]
	// state
	serialized = serialized[6:]
	for i := 0; i < 25; i++ {
		a := binary.LittleEndian.Uint64(serialized[:8])
		s.a[i] = a
		serialized = serialized[8:]
	}
	//
	return
}

//
// Flags
//

type flag uint8

const (
	flagI flag = 1 << iota
	flagA
	flagC
	flagT
	flagM
	flagK
)

var operationMap = map[string]flag{
	"AD":       flagA,
	"KEY":      flagA | flagC,
	"PRF":      flagI | flagA | flagC,
	"send_CLR": flagA | flagT,
	"recv_CLR": flagI | flagA | flagT,
	"send_ENC": flagA | flagC | flagT,
	"recv_ENC": flagI | flagA | flagC | flagT,
	"send_MAC": flagC | flagT,
	"recv_MAC": flagI | flagC | flagT,
	"RATCHET":  flagC,
}

//
// Helper
//

// this only works for 8-byte alligned buffers
func xorState(state *[25]uint64, buf []byte) {
	n := len(buf) / 8
	for i := 0; i < n; i++ {
		a := binary.LittleEndian.Uint64(buf)
		state[i] ^= a
		buf = buf[8:]
	}
}

// this only works for 8-byte alligned buffers
func outState(state [25]uint64, b []byte) {
	for i := 0; len(b) >= 8; i++ {
		binary.LittleEndian.PutUint64(b, state[i])
		b = b[8:]
	}
}

// since the golang implementation does not absorb
// things in the state "right away" (sometimes just
// wait for the buffer to fill) we need a function
// to properly print the state even when the state
// is in this "temporary" state.
func (s Strobe) debugPrintState() string {
	// copy _storage into buf
	var buf [1600 / 8]byte
	copy(buf[:len(s.buf)], s.storage[:len(s.buf)])
	// copy _state into state
	var state [25]uint64
	copy(state[:], s.a[:])
	// xor
	xorState(&state, buf[:])
	// print
	outState(state, buf[:])
	return hex.EncodeToString(buf[:])
}

//
// Core functions
//

// InitStrobe allows you to initialize a new strobe instance with a customization string (that can be empty) and a security target (either 128 or 256).
func InitStrobe(customizationString string, security int) (s Strobe) {
	// compute security and rate
	if security != 128 && security != 256 {
		panic("strobe: security must be set to either 128 or 256")
	}
	s.duplexRate = 1600/8 - security/4
	s.StrobeR = s.duplexRate - 2
	// init vars
	s.storage = make([]byte, s.duplexRate)
	s.tempStateBuf = make([]byte, s.duplexRate)
	s.I0 = iNone
	s.initialized = false
	// absorb domain + initialize + absorb custom string
	domain := []byte{1, byte(s.StrobeR + 2), 1, 0, 1, 12 * 8}
	domain = append(domain, []byte("STROBEv1.0.2")...)
	s.buf = s.storage[:0]
	s.duplex(domain, false, false, true)
	s.initialized = true
	s.Operate(true, "AD", []byte(customizationString), 0, false)

	return
}

// runF: applies the STROBE's + cSHAKE's padding and the Keccak permutation
func (s *Strobe) runF() {
	if s.initialized {
		// if we're initialize we apply the strobe padding
		if len(s.buf) > s.StrobeR {
			panic("strobe: buffer is never supposed to reach strobeR")
		}
		s.buf = append(s.buf, s.posBegin)
		s.buf = append(s.buf, 0x04)
		zerosStart := len(s.buf)
		s.buf = s.storage[:s.duplexRate]
		for i := zerosStart; i < s.duplexRate; i++ {
			s.buf[i] = 0
		}
		s.buf[s.duplexRate-1] ^= 0x80
		xorState(&s.a, s.buf)
	} else if len(s.buf) != 0 {
		// otherwise we just pad with 0s for xorState to work
		zerosStart := len(s.buf) // rate = [0--end_of_buffer/zeroStart---duplexRate]
		s.buf = s.storage[:s.duplexRate]
		for i := zerosStart; i < s.duplexRate; i++ {
			s.buf[i] = 0
		}
		xorState(&s.a, s.buf)
	}

	// run the permutation
	keccakF1600(&s.a, 24)

	// reset the buffer and set posBegin to 0
	// (meaning that the current operation started on a previous block)
	s.buf = s.storage[:0]
	s.posBegin = 0
}

// duplex: the duplex call
func (s *Strobe) duplex(data []byte, cbefore, cafter, forceF bool) {

	// process data block by block
	for len(data) > 0 {

		todo := s.StrobeR - len(s.buf)
		if todo > len(data) {
			todo = len(data)
		}

		if cbefore {
			outState(s.a, s.tempStateBuf)
			for idx, state := range s.tempStateBuf[len(s.buf) : len(s.buf)+todo] {
				data[idx] ^= state
			}
		}

		// buffer what's to be XOR'ed (we XOR once during runF)
		s.buf = append(s.buf, data[:todo]...)

		if cafter {
			outState(s.a, s.tempStateBuf)
			for idx, state := range s.tempStateBuf[len(s.buf)-todo : len(s.buf)] {
				data[idx] ^= state
			}
		}

		// what's next for the loop?
		data = data[todo:]

		// If the duplex is full, time to XOR + padd + permutate.
		if len(s.buf) == s.StrobeR {
			s.runF()
		}

	}

	// sometimes we the next operation to start on a new block
	if forceF && len(s.buf) != 0 {
		s.runF()
	}

	return
}

// Operate runs an operation (see OperationMap for a list of operations).
// For operations that only require a length, provide the length via the
// length argument with an empty slice []byte{}. For other operations provide
// a zero length.
// Result is always retrieved through the return value. For boolean results,
// check that the first index is 0 for true, 1 for false.
func (s *Strobe) Operate(meta bool, operation string, dataConst []byte, length int, more bool) []byte {
	// operation is valid?
	var flags flag
	var ok bool
	if flags, ok = operationMap[operation]; !ok {
		panic("not a valid operation")
	}

	// operation is meta?
	if meta {
		flags |= flagM
	}

	// does the operation requires a length?
	var data []byte

	if (flags&(flagI|flagT) != (flagI | flagT)) && (flags&(flagI|flagA) != flagA) {

		if length == 0 {
			panic("A length should be set for this operation.")
		}

		data = bytes.Repeat([]byte{0}, length)

	} else {
		if length != 0 {
			panic("Output length must be zero except for PRF, send_MAC and RATCHET operations.")
		}

		data = make([]byte, len(dataConst))
		copy(data, dataConst)
	}

	// is this call the continuity of a previous call?
	if more {
		if flags != s.curFlags {
			panic("Flag should be the same when streaming operations.")
		}
	} else {
		s.beginOp(flags)
		s.curFlags = flags
	}

	// Operation
	cAfter := (flags & (flagC | flagI | flagT)) == (flagC | flagT)
	cBefore := (flags&flagC != 0) && (!cAfter)

	s.duplex(data, cBefore, cAfter, false)

	if (flags & (flagI | flagA)) == (flagI | flagA) {
		// Return data for the application
		return data
	} else if (flags & (flagI | flagT)) == flagT {
		// Return data for the transport.
		return data
	} else if (flags & (flagI | flagA | flagT)) == (flagI | flagT) {
		// Check MAC: all output bytes must be 0
		if more {
			panic("not supposed to check a MAC with the 'more' streaming option")
		}
		var failures byte
		for _, dataByte := range data {
			failures |= dataByte
		}
		return []byte{failures} // 0 if correct, 1 if not
	}

	// Operation has no output
	return nil
}

// beginOp: starts an operation
func (s *Strobe) beginOp(flags flag) {

	if flags&flagT != 0 {
		if s.I0 == iNone {
			s.I0 = role(flags & flagI)
		}
		flags ^= flag(s.I0)
	}

	oldBegin := s.posBegin
	s.posBegin = uint8(len(s.buf) + 1) // s.pos + 1
	forceF := (flags&(flagC|flagK) != 0)
	s.duplex([]byte{oldBegin, byte(flags)}, false, false, forceF)
}

===========================================

File Path: ./vendor/github.com/mimoo/StrobeGo/strobe/keccakf.go
File Name: keccakf.go

===========================================

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//  +build !amd64 appengine gccgo

package strobe

// rc stores the round constants for use in the  step.
var rc = [24]uint64{
	0x0000000000000001,
	0x0000000000008082,
	0x800000000000808A,
	0x8000000080008000,
	0x000000000000808B,
	0x0000000080000001,
	0x8000000080008081,
	0x8000000000008009,
	0x000000000000008A,
	0x0000000000000088,
	0x0000000080008009,
	0x000000008000000A,
	0x000000008000808B,
	0x800000000000008B,
	0x8000000000008089,
	0x8000000000008003,
	0x8000000000008002,
	0x8000000000000080,
	0x000000000000800A,
	0x800000008000000A,
	0x8000000080008081,
	0x8000000000008080,
	0x0000000080000001,
	0x8000000080008008,
}

// keccakF1600 applies the Keccak permutation to a 1600b-wide
// state represented as a slice of 25 uint64s.
func keccakF1600(a *[25]uint64, nr int) {
	// Implementation translated from Keccak-inplace.c
	// in the keccak reference code.
	var t, bc0, bc1, bc2, bc3, bc4, d0, d1, d2, d3, d4 uint64

	for i := 0; i < 24; i += 4 {
		if i+nr >= 24 {
			// Combines the 5 steps in each round into 2 steps.
			// Unrolls 4 rounds per loop and spreads some steps across rounds.

			// Round 1
			bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
			bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
			bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22]
			bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23]
			bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24]
			d0 = bc4 ^ (bc1<<1 | bc1>>63)
			d1 = bc0 ^ (bc2<<1 | bc2>>63)
			d2 = bc1 ^ (bc3<<1 | bc3>>63)
			d3 = bc2 ^ (bc4<<1 | bc4>>63)
			d4 = bc3 ^ (bc0<<1 | bc0>>63)

			bc0 = a[0] ^ d0
			t = a[6] ^ d1
			bc1 = t<<44 | t>>(64-44)
			t = a[12] ^ d2
			bc2 = t<<43 | t>>(64-43)
			t = a[18] ^ d3
			bc3 = t<<21 | t>>(64-21)
			t = a[24] ^ d4
			bc4 = t<<14 | t>>(64-14)
			a[0] = bc0 ^ (bc2 &^ bc1) ^ rc[i]
			a[6] = bc1 ^ (bc3 &^ bc2)
			a[12] = bc2 ^ (bc4 &^ bc3)
			a[18] = bc3 ^ (bc0 &^ bc4)
			a[24] = bc4 ^ (bc1 &^ bc0)

			t = a[10] ^ d0
			bc2 = t<<3 | t>>(64-3)
			t = a[16] ^ d1
			bc3 = t<<45 | t>>(64-45)
			t = a[22] ^ d2
			bc4 = t<<61 | t>>(64-61)
			t = a[3] ^ d3
			bc0 = t<<28 | t>>(64-28)
			t = a[9] ^ d4
			bc1 = t<<20 | t>>(64-20)
			a[10] = bc0 ^ (bc2 &^ bc1)
			a[16] = bc1 ^ (bc3 &^ bc2)
			a[22] = bc2 ^ (bc4 &^ bc3)
			a[3] = bc3 ^ (bc0 &^ bc4)
			a[9] = bc4 ^ (bc1 &^ bc0)

			t = a[20] ^ d0
			bc4 = t<<18 | t>>(64-18)
			t = a[1] ^ d1
			bc0 = t<<1 | t>>(64-1)
			t = a[7] ^ d2
			bc1 = t<<6 | t>>(64-6)
			t = a[13] ^ d3
			bc2 = t<<25 | t>>(64-25)
			t = a[19] ^ d4
			bc3 = t<<8 | t>>(64-8)
			a[20] = bc0 ^ (bc2 &^ bc1)
			a[1] = bc1 ^ (bc3 &^ bc2)
			a[7] = bc2 ^ (bc4 &^ bc3)
			a[13] = bc3 ^ (bc0 &^ bc4)
			a[19] = bc4 ^ (bc1 &^ bc0)

			t = a[5] ^ d0
			bc1 = t<<36 | t>>(64-36)
			t = a[11] ^ d1
			bc2 = t<<10 | t>>(64-10)
			t = a[17] ^ d2
			bc3 = t<<15 | t>>(64-15)
			t = a[23] ^ d3
			bc4 = t<<56 | t>>(64-56)
			t = a[4] ^ d4
			bc0 = t<<27 | t>>(64-27)
			a[5] = bc0 ^ (bc2 &^ bc1)
			a[11] = bc1 ^ (bc3 &^ bc2)
			a[17] = bc2 ^ (bc4 &^ bc3)
			a[23] = bc3 ^ (bc0 &^ bc4)
			a[4] = bc4 ^ (bc1 &^ bc0)

			t = a[15] ^ d0
			bc3 = t<<41 | t>>(64-41)
			t = a[21] ^ d1
			bc4 = t<<2 | t>>(64-2)
			t = a[2] ^ d2
			bc0 = t<<62 | t>>(64-62)
			t = a[8] ^ d3
			bc1 = t<<55 | t>>(64-55)
			t = a[14] ^ d4
			bc2 = t<<39 | t>>(64-39)
			a[15] = bc0 ^ (bc2 &^ bc1)
			a[21] = bc1 ^ (bc3 &^ bc2)
			a[2] = bc2 ^ (bc4 &^ bc3)
			a[8] = bc3 ^ (bc0 &^ bc4)
			a[14] = bc4 ^ (bc1 &^ bc0)

			// Round 2
			bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
			bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
			bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22]
			bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23]
			bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24]
			d0 = bc4 ^ (bc1<<1 | bc1>>63)
			d1 = bc0 ^ (bc2<<1 | bc2>>63)
			d2 = bc1 ^ (bc3<<1 | bc3>>63)
			d3 = bc2 ^ (bc4<<1 | bc4>>63)
			d4 = bc3 ^ (bc0<<1 | bc0>>63)

			bc0 = a[0] ^ d0
			t = a[16] ^ d1
			bc1 = t<<44 | t>>(64-44)
			t = a[7] ^ d2
			bc2 = t<<43 | t>>(64-43)
			t = a[23] ^ d3
			bc3 = t<<21 | t>>(64-21)
			t = a[14] ^ d4
			bc4 = t<<14 | t>>(64-14)
			a[0] = bc0 ^ (bc2 &^ bc1) ^ rc[i+1]
			a[16] = bc1 ^ (bc3 &^ bc2)
			a[7] = bc2 ^ (bc4 &^ bc3)
			a[23] = bc3 ^ (bc0 &^ bc4)
			a[14] = bc4 ^ (bc1 &^ bc0)

			t = a[20] ^ d0
			bc2 = t<<3 | t>>(64-3)
			t = a[11] ^ d1
			bc3 = t<<45 | t>>(64-45)
			t = a[2] ^ d2
			bc4 = t<<61 | t>>(64-61)
			t = a[18] ^ d3
			bc0 = t<<28 | t>>(64-28)
			t = a[9] ^ d4
			bc1 = t<<20 | t>>(64-20)
			a[20] = bc0 ^ (bc2 &^ bc1)
			a[11] = bc1 ^ (bc3 &^ bc2)
			a[2] = bc2 ^ (bc4 &^ bc3)
			a[18] = bc3 ^ (bc0 &^ bc4)
			a[9] = bc4 ^ (bc1 &^ bc0)

			t = a[15] ^ d0
			bc4 = t<<18 | t>>(64-18)
			t = a[6] ^ d1
			bc0 = t<<1 | t>>(64-1)
			t = a[22] ^ d2
			bc1 = t<<6 | t>>(64-6)
			t = a[13] ^ d3
			bc2 = t<<25 | t>>(64-25)
			t = a[4] ^ d4
			bc3 = t<<8 | t>>(64-8)
			a[15] = bc0 ^ (bc2 &^ bc1)
			a[6] = bc1 ^ (bc3 &^ bc2)
			a[22] = bc2 ^ (bc4 &^ bc3)
			a[13] = bc3 ^ (bc0 &^ bc4)
			a[4] = bc4 ^ (bc1 &^ bc0)

			t = a[10] ^ d0
			bc1 = t<<36 | t>>(64-36)
			t = a[1] ^ d1
			bc2 = t<<10 | t>>(64-10)
			t = a[17] ^ d2
			bc3 = t<<15 | t>>(64-15)
			t = a[8] ^ d3
			bc4 = t<<56 | t>>(64-56)
			t = a[24] ^ d4
			bc0 = t<<27 | t>>(64-27)
			a[10] = bc0 ^ (bc2 &^ bc1)
			a[1] = bc1 ^ (bc3 &^ bc2)
			a[17] = bc2 ^ (bc4 &^ bc3)
			a[8] = bc3 ^ (bc0 &^ bc4)
			a[24] = bc4 ^ (bc1 &^ bc0)

			t = a[5] ^ d0
			bc3 = t<<41 | t>>(64-41)
			t = a[21] ^ d1
			bc4 = t<<2 | t>>(64-2)
			t = a[12] ^ d2
			bc0 = t<<62 | t>>(64-62)
			t = a[3] ^ d3
			bc1 = t<<55 | t>>(64-55)
			t = a[19] ^ d4
			bc2 = t<<39 | t>>(64-39)
			a[5] = bc0 ^ (bc2 &^ bc1)
			a[21] = bc1 ^ (bc3 &^ bc2)
			a[12] = bc2 ^ (bc4 &^ bc3)
			a[3] = bc3 ^ (bc0 &^ bc4)
			a[19] = bc4 ^ (bc1 &^ bc0)

			// Round 3
			bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
			bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
			bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22]
			bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23]
			bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24]
			d0 = bc4 ^ (bc1<<1 | bc1>>63)
			d1 = bc0 ^ (bc2<<1 | bc2>>63)
			d2 = bc1 ^ (bc3<<1 | bc3>>63)
			d3 = bc2 ^ (bc4<<1 | bc4>>63)
			d4 = bc3 ^ (bc0<<1 | bc0>>63)

			bc0 = a[0] ^ d0
			t = a[11] ^ d1
			bc1 = t<<44 | t>>(64-44)
			t = a[22] ^ d2
			bc2 = t<<43 | t>>(64-43)
			t = a[8] ^ d3
			bc3 = t<<21 | t>>(64-21)
			t = a[19] ^ d4
			bc4 = t<<14 | t>>(64-14)
			a[0] = bc0 ^ (bc2 &^ bc1) ^ rc[i+2]
			a[11] = bc1 ^ (bc3 &^ bc2)
			a[22] = bc2 ^ (bc4 &^ bc3)
			a[8] = bc3 ^ (bc0 &^ bc4)
			a[19] = bc4 ^ (bc1 &^ bc0)

			t = a[15] ^ d0
			bc2 = t<<3 | t>>(64-3)
			t = a[1] ^ d1
			bc3 = t<<45 | t>>(64-45)
			t = a[12] ^ d2
			bc4 = t<<61 | t>>(64-61)
			t = a[23] ^ d3
			bc0 = t<<28 | t>>(64-28)
			t = a[9] ^ d4
			bc1 = t<<20 | t>>(64-20)
			a[15] = bc0 ^ (bc2 &^ bc1)
			a[1] = bc1 ^ (bc3 &^ bc2)
			a[12] = bc2 ^ (bc4 &^ bc3)
			a[23] = bc3 ^ (bc0 &^ bc4)
			a[9] = bc4 ^ (bc1 &^ bc0)

			t = a[5] ^ d0
			bc4 = t<<18 | t>>(64-18)
			t = a[16] ^ d1
			bc0 = t<<1 | t>>(64-1)
			t = a[2] ^ d2
			bc1 = t<<6 | t>>(64-6)
			t = a[13] ^ d3
			bc2 = t<<25 | t>>(64-25)
			t = a[24] ^ d4
			bc3 = t<<8 | t>>(64-8)
			a[5] = bc0 ^ (bc2 &^ bc1)
			a[16] = bc1 ^ (bc3 &^ bc2)
			a[2] = bc2 ^ (bc4 &^ bc3)
			a[13] = bc3 ^ (bc0 &^ bc4)
			a[24] = bc4 ^ (bc1 &^ bc0)

			t = a[20] ^ d0
			bc1 = t<<36 | t>>(64-36)
			t = a[6] ^ d1
			bc2 = t<<10 | t>>(64-10)
			t = a[17] ^ d2
			bc3 = t<<15 | t>>(64-15)
			t = a[3] ^ d3
			bc4 = t<<56 | t>>(64-56)
			t = a[14] ^ d4
			bc0 = t<<27 | t>>(64-27)
			a[20] = bc0 ^ (bc2 &^ bc1)
			a[6] = bc1 ^ (bc3 &^ bc2)
			a[17] = bc2 ^ (bc4 &^ bc3)
			a[3] = bc3 ^ (bc0 &^ bc4)
			a[14] = bc4 ^ (bc1 &^ bc0)

			t = a[10] ^ d0
			bc3 = t<<41 | t>>(64-41)
			t = a[21] ^ d1
			bc4 = t<<2 | t>>(64-2)
			t = a[7] ^ d2
			bc0 = t<<62 | t>>(64-62)
			t = a[18] ^ d3
			bc1 = t<<55 | t>>(64-55)
			t = a[4] ^ d4
			bc2 = t<<39 | t>>(64-39)
			a[10] = bc0 ^ (bc2 &^ bc1)
			a[21] = bc1 ^ (bc3 &^ bc2)
			a[7] = bc2 ^ (bc4 &^ bc3)
			a[18] = bc3 ^ (bc0 &^ bc4)
			a[4] = bc4 ^ (bc1 &^ bc0)

			// Round 4
			bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
			bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
			bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22]
			bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23]
			bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24]
			d0 = bc4 ^ (bc1<<1 | bc1>>63)
			d1 = bc0 ^ (bc2<<1 | bc2>>63)
			d2 = bc1 ^ (bc3<<1 | bc3>>63)
			d3 = bc2 ^ (bc4<<1 | bc4>>63)
			d4 = bc3 ^ (bc0<<1 | bc0>>63)

			bc0 = a[0] ^ d0
			t = a[1] ^ d1
			bc1 = t<<44 | t>>(64-44)
			t = a[2] ^ d2
			bc2 = t<<43 | t>>(64-43)
			t = a[3] ^ d3
			bc3 = t<<21 | t>>(64-21)
			t = a[4] ^ d4
			bc4 = t<<14 | t>>(64-14)
			a[0] = bc0 ^ (bc2 &^ bc1) ^ rc[i+3]
			a[1] = bc1 ^ (bc3 &^ bc2)
			a[2] = bc2 ^ (bc4 &^ bc3)
			a[3] = bc3 ^ (bc0 &^ bc4)
			a[4] = bc4 ^ (bc1 &^ bc0)

			t = a[5] ^ d0
			bc2 = t<<3 | t>>(64-3)
			t = a[6] ^ d1
			bc3 = t<<45 | t>>(64-45)
			t = a[7] ^ d2
			bc4 = t<<61 | t>>(64-61)
			t = a[8] ^ d3
			bc0 = t<<28 | t>>(64-28)
			t = a[9] ^ d4
			bc1 = t<<20 | t>>(64-20)
			a[5] = bc0 ^ (bc2 &^ bc1)
			a[6] = bc1 ^ (bc3 &^ bc2)
			a[7] = bc2 ^ (bc4 &^ bc3)
			a[8] = bc3 ^ (bc0 &^ bc4)
			a[9] = bc4 ^ (bc1 &^ bc0)

			t = a[10] ^ d0
			bc4 = t<<18 | t>>(64-18)
			t = a[11] ^ d1
			bc0 = t<<1 | t>>(64-1)
			t = a[12] ^ d2
			bc1 = t<<6 | t>>(64-6)
			t = a[13] ^ d3
			bc2 = t<<25 | t>>(64-25)
			t = a[14] ^ d4
			bc3 = t<<8 | t>>(64-8)
			a[10] = bc0 ^ (bc2 &^ bc1)
			a[11] = bc1 ^ (bc3 &^ bc2)
			a[12] = bc2 ^ (bc4 &^ bc3)
			a[13] = bc3 ^ (bc0 &^ bc4)
			a[14] = bc4 ^ (bc1 &^ bc0)

			t = a[15] ^ d0
			bc1 = t<<36 | t>>(64-36)
			t = a[16] ^ d1
			bc2 = t<<10 | t>>(64-10)
			t = a[17] ^ d2
			bc3 = t<<15 | t>>(64-15)
			t = a[18] ^ d3
			bc4 = t<<56 | t>>(64-56)
			t = a[19] ^ d4
			bc0 = t<<27 | t>>(64-27)
			a[15] = bc0 ^ (bc2 &^ bc1)
			a[16] = bc1 ^ (bc3 &^ bc2)
			a[17] = bc2 ^ (bc4 &^ bc3)
			a[18] = bc3 ^ (bc0 &^ bc4)
			a[19] = bc4 ^ (bc1 &^ bc0)

			t = a[20] ^ d0
			bc3 = t<<41 | t>>(64-41)
			t = a[21] ^ d1
			bc4 = t<<2 | t>>(64-2)
			t = a[22] ^ d2
			bc0 = t<<62 | t>>(64-62)
			t = a[23] ^ d3
			bc1 = t<<55 | t>>(64-55)
			t = a[24] ^ d4
			bc2 = t<<39 | t>>(64-39)
			a[20] = bc0 ^ (bc2 &^ bc1)
			a[21] = bc1 ^ (bc3 &^ bc2)
			a[22] = bc2 ^ (bc4 &^ bc3)
			a[23] = bc3 ^ (bc0 &^ bc4)
			a[24] = bc4 ^ (bc1 &^ bc0)
		}
	}
}

===========================================

File Path: ./vendor/github.com/gtank/merlin/merlin.go
File Name: merlin.go

===========================================

package merlin

import (
	"encoding/binary"

	"github.com/mimoo/StrobeGo/strobe"
)

const (
	merlinProtocolLabel  = "Merlin v1.0"
	domainSeparatorLabel = "dom-sep"
)

type Transcript struct {
	s strobe.Strobe
}

func NewTranscript(appLabel string) *Transcript {
	t := Transcript{
		s: strobe.InitStrobe(merlinProtocolLabel, 128),
	}

	t.AppendMessage([]byte(domainSeparatorLabel), []byte(appLabel))
	return &t
}

// Append adds the message to the transcript with the supplied label.
func (t *Transcript) AppendMessage(label, message []byte) {
	// AD[label || le32(len(message))](message)

	sizeBuffer := make([]byte, 4)
	binary.LittleEndian.PutUint32(sizeBuffer[0:], uint32(len(message)))

	// The StrobeGo API does not support continuation operations,
	// so we have to pass the label and length as a single buffer.
	// Otherwise it will record two meta-AD operations instead of one.
	labelSize := append(label, sizeBuffer...)
	t.s.AD(true, labelSize)

	t.s.AD(false, message)
}

// ExtractBytes returns a buffer filled with the verifier's challenge bytes.
// The label parameter is metadata about the challenge, and is also appended to
// the transcript. See the Transcript Protocols section of the Merlin website
// for details on labels.
func (t *Transcript) ExtractBytes(label []byte, outLen int) []byte {
	sizeBuffer := make([]byte, 4)
	binary.LittleEndian.PutUint32(sizeBuffer[0:], uint32(outLen))

	// The StrobeGo API does not support continuation operations,
	// so we have to pass the label and length as a single buffer.
	// Otherwise it will record two meta-AD operations instead of one.
	labelSize := append(label, sizeBuffer...)
	t.s.AD(true, labelSize)

	// A PRF call directly to the output buffer (in the style of an append API)
	// would be better, but our underlying STROBE library forces an allocation
	// here.
	outBytes := t.s.PRF(outLen)
	return outBytes
}

===========================================

File Path: ./pkg/crypto/encryption.go
File Name: encryption.go

===========================================

// pkg/crypto/encryption.go
package crypto

import (
	"crypto/rand"
	"github.com/cloudflare/bn256"
	"math/big"
)

func EncryptVote(pubKey *bn256.G1, vote int) ([]*bn256.G1, error) {
	r, _ := rand.Int(rand.Reader, bn256.Order)

	// Create the first part of the ciphertext: g^r
	c1 := new(bn256.G1).ScalarBaseMult(r)

	// Create the second part: pubKey^r * g^vote
	votePoint := new(bn256.G1).ScalarBaseMult(big.NewInt(int64(vote)))
	temp := new(bn256.G1).ScalarMult(pubKey, r)
	c2 := new(bn256.G1).Add(temp, votePoint)

	return []*bn256.G1{c1, c2}, nil
}

===========================================

File Path: ./pkg/crypto/keys.go
File Name: keys.go

===========================================

// pkg/crypto/keys.go
package crypto

import (
	"crypto/rand"
	"github.com/cloudflare/bn256"
	"math/big"
)

type KeyPair struct {
	PrivateKey *big.Int
	PublicKey  *bn256.G1
}

func GenerateKeys() *KeyPair {
	priv, _ := rand.Int(rand.Reader, bn256.Order)
	pub := new(bn256.G1).ScalarBaseMult(priv)
	return &KeyPair{priv, pub}
}

===========================================

File Path: ./pkg/crypto/zkp.go
File Name: zkp.go

===========================================

package crypto

import (
	"bytes"
	"math/big"

	"github.com/cloudflare/bn256"
	"github.com/gtank/merlin"
)

func GenerateVoteProof(ciphertext []*bn256.G1, r *big.Int, vote int) []byte {
	transcript := merlin.NewTranscript("vote_proof")
	transcript.AppendMessage([]byte("commitment"), ciphertext[0].Marshal())
	transcript.AppendMessage([]byte("ciphertext"), ciphertext[1].Marshal())

	// Use the challenge in the proof calculation or remove it if not needed
	// The following line is a simplified way to use the challenge
	challenge := transcript.ExtractBytes([]byte("challenge"), 32)

	// Create a proof that combines the random value r with the challenge
	// This is a simplified implementation - a real ZKP would be more complex
	challengeInt := new(big.Int).SetBytes(challenge)
	proofInt := new(big.Int).Add(r, challengeInt)

	// Return the proof as a marshaled point
	proof := new(bn256.G1).ScalarBaseMult(proofInt)
	return proof.Marshal()
}

func VerifyZKProof(transcript *merlin.Transcript, ciphertext []*bn256.G1, proof []byte) bool {
	transcript.AppendMessage([]byte("commitment"), ciphertext[0].Marshal())
	transcript.AppendMessage([]byte("ciphertext"), ciphertext[1].Marshal())

	challenge := transcript.ExtractBytes([]byte("challenge"), 32)

	// Recreate the expected proof point
	expectedInt := new(big.Int).SetBytes(challenge)
	expected := new(bn256.G1).ScalarBaseMult(expectedInt)

	// Unmarshal the provided proof
	actual, err := new(bn256.G1).Unmarshal(proof)
	if err != nil {
		return false
	}

	// Compare the expected and actual proofs
	// In a real implementation, this would verify the mathematical relationship
	return bytes.Equal(expected.Marshal(), actual)
}

===========================================

File Path: ./pkg/network/p2p.go
File Name: p2p.go

===========================================

// pkg/network/p2p.go
package network

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/koushamad/election-system/pkg/blockchain"
	"io/ioutil"
	"net/http"
	"sync"
	"time"
)

type P2PNetwork struct {
	NodeAddress string
	KnownPeers  map[string]bool
	mu          sync.RWMutex
	node        *blockchain.Node
}

func NewP2PNetwork(nodeAddr string, node *blockchain.Node) *P2PNetwork {
	return &P2PNetwork{
		NodeAddress: nodeAddr,
		KnownPeers:  make(map[string]bool),
		node:        node,
	}
}

func (p *P2PNetwork) AddPeer(peerAddr string) {
	p.mu.Lock()
	defer p.mu.Unlock()

	if peerAddr != p.NodeAddress && !p.KnownPeers[peerAddr] {
		p.KnownPeers[peerAddr] = true
		go p.SyncWithPeer(peerAddr)
	}
}

func (p *P2PNetwork) BroadcastBlock(block *blockchain.Block) {
	p.mu.RLock()
	defer p.mu.RUnlock()

	for peer := range p.KnownPeers {
		go func(peerAddr string) {
			blockData, _ := json.Marshal(block)
			http.Post(fmt.Sprintf("http://%s/blocks", peerAddr),
				"application/json", bytes.NewBuffer(blockData))
		}(peer)
	}
}

func (p *P2PNetwork) BroadcastTransaction(tx *blockchain.Transaction) {
	p.mu.RLock()
	defer p.mu.RUnlock()

	for peer := range p.KnownPeers {
		go func(peerAddr string) {
			txData, _ := json.Marshal(tx)
			http.Post(fmt.Sprintf("http://%s/transactions", peerAddr),
				"application/json", bytes.NewBuffer(txData))
		}(peer)
	}
}

func (p *P2PNetwork) SyncWithPeer(peerAddr string) {
	// Get peer's blockchain
	resp, err := http.Get(fmt.Sprintf("http://%s/chain", peerAddr))
	if err != nil {
		fmt.Printf("Failed to sync with peer %s: %v\n", peerAddr, err)
		return
	}
	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	var peerChain blockchain.Chain
	json.Unmarshal(body, &peerChain)

	// Compare with our chain and resolve conflicts
	if len(peerChain.Blocks) > len(p.node.Chain.Blocks) {
		// Verify the peer's chain
		if p.node.VerifyChain(&peerChain) {
			p.node.ReplaceChain(&peerChain)
			fmt.Printf("Replaced chain with peer %s\n", peerAddr)
		}
	}

	// Get peer's known peers
	resp, err = http.Get(fmt.Sprintf("http://%s/peers", peerAddr))
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, _ = ioutil.ReadAll(resp.Body)
	var peers []string
	json.Unmarshal(body, &peers)

	// Add new peers
	for _, peer := range peers {
		p.AddPeer(peer)
	}
}

func (p *P2PNetwork) StartSyncLoop() {
	ticker := time.NewTicker(30 * time.Second)
	go func() {
		for {
			<-ticker.C
			p.mu.RLock()
			peers := make([]string, 0, len(p.KnownPeers))
			for peer := range p.KnownPeers {
				peers = append(peers, peer)
			}
			p.mu.RUnlock()

			for _, peer := range peers {
				go p.SyncWithPeer(peer)
			}
		}
	}()
}

===========================================

File Path: ./pkg/network/server.go
File Name: server.go

===========================================

// pkg/network/server.go
package network

import (
	"encoding/json"
	"fmt"
	"github.com/koushamad/election-system/pkg/blockchain"
	"net/http"
)

type Server struct {
	Node   *blockchain.Node
	Port   int
	P2PNet *P2PNetwork
}

func NewServer(node *blockchain.Node, port int) *Server {
	server := &Server{
		Node: node,
		Port: port,
	}

	nodeAddr := fmt.Sprintf("localhost:%d", port)
	server.P2PNet = NewP2PNetwork(nodeAddr, node)

	return server
}

func (s *Server) Start() error {
	// Chain endpoints
	http.HandleFunc("/chain", s.handleGetChain)
	http.HandleFunc("/blocks", s.handleBlocks)
	http.HandleFunc("/transactions", s.handleTransactions)

	// P2P endpoints
	http.HandleFunc("/peers", s.handlePeers)
	http.HandleFunc("/addPeer", s.handleAddPeer)

	// Start P2P sync
	s.P2PNet.StartSyncLoop()

	// Load initial peers from config
	s.loadInitialPeers()

	fmt.Printf("Server running on port %d\n", s.Port)
	return http.ListenAndServe(fmt.Sprintf(":%d", s.Port), nil)
}

func (s *Server) handleGetChain(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(s.Node.Chain)
}

func (s *Server) handleBlocks(w http.ResponseWriter, r *http.Request) {
	if r.Method == "POST" {
		var block blockchain.Block
		if err := json.NewDecoder(r.Body).Decode(&block); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		// Verify and add block
		if err := s.Node.AddBlock(&block); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		w.WriteHeader(http.StatusCreated)
	} else {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleTransactions(w http.ResponseWriter, r *http.Request) {
	if r.Method == "POST" {
		var tx blockchain.Transaction
		if err := json.NewDecoder(r.Body).Decode(&tx); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		// Verify and add transaction
		if err := s.Node.AddTransaction(&tx); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		// Broadcast to peers
		s.P2PNet.BroadcastTransaction(&tx)

		w.WriteHeader(http.StatusCreated)
	} else if r.Method == "GET" {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(s.Node.TransactionPool)
	} else {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handlePeers(w http.ResponseWriter, r *http.Request) {
	s.P2PNet.mu.RLock()
	defer s.P2PNet.mu.RUnlock()

	peers := make([]string, 0, len(s.P2PNet.KnownPeers))
	for peer := range s.P2PNet.KnownPeers {
		peers = append(peers, peer)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(peers)
}

func (s *Server) handleAddPeer(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Peer string `json:"peer"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	s.P2PNet.AddPeer(req.Peer)
	w.WriteHeader(http.StatusCreated)
}

func (s *Server) loadInitialPeers() {
	// This would normally load from config.yaml
	// For simplicity, we'll hardcode some peers
	initialPeers := []string{
		"localhost:5001",
		"localhost:5002",
	}

	for _, peer := range initialPeers {
		if peer != s.P2PNet.NodeAddress {
			s.P2PNet.AddPeer(peer)
		}
	}
}

===========================================

File Path: ./pkg/blockchain/transaction.go
File Name: transaction.go

===========================================

// pkg/blockchain/transaction.go
package blockchain

import (
	"bytes"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"time"
)

type TransactionType string

const (
	TxCreateElection TransactionType = "create_election"
	TxCastVote       TransactionType = "cast_vote"
	TxTallyVotes     TransactionType = "tally_votes"
)

type Transaction struct {
	ID        string          `json:"id"`
	Type      TransactionType `json:"type"`
	Payload   json.RawMessage `json:"payload"`
	Hash      []byte          `json:"hash"`
	Timestamp int64           `json:"timestamp"`
	Signature []byte          `json:"signature"`
	PublicKey []byte          `json:"public_key"` // Sender's public key
}

func NewTransaction(txType TransactionType, payload interface{}) (*Transaction, error) {
	payloadBytes, err := json.Marshal(payload)
	if err != nil {
		return nil, err
	}

	tx := &Transaction{
		ID:        GenerateUUID(),
		Type:      txType,
		Payload:   payloadBytes,
		Timestamp: time.Now().Unix(),
	}

	tx.Hash = tx.CalculateHash()
	return tx, nil
}

func (t *Transaction) CalculateHash() []byte {
	txData := struct {
		ID        string
		Type      TransactionType
		Payload   json.RawMessage
		Timestamp int64
		PublicKey []byte
	}{
		ID:        t.ID,
		Type:      t.Type,
		Payload:   t.Payload,
		Timestamp: t.Timestamp,
		PublicKey: t.PublicKey,
	}

	data, _ := json.Marshal(txData)
	hash := sha256.Sum256(data)
	return hash[:]
}

func (t *Transaction) Validate() bool {
	// Basic validation
	if t.ID == "" || len(t.Hash) == 0 {
		return false
	}

	// For testing purposes, detect manually corrupted hash
	if string(t.Hash) == "invalid-hash" {
		return false
	}

	// Verify hash matches the calculated hash
	calculatedHash := t.CalculateHash()
	return bytes.Equal(calculatedHash, t.Hash)
}

// Helper function to generate a UUID
func GenerateUUID() string {
	// Simple implementation for demonstration purposes
	hash := sha256.Sum256([]byte(time.Now().String()))
	return fmt.Sprintf("%x", hash[:8])
}

===========================================

File Path: ./pkg/blockchain/chain.go
File Name: chain.go

===========================================

// pkg/blockchain/chain.go
package blockchain

import (
	"bytes"
	"errors"
	"time"
)

type Chain struct {
	Blocks              []*Block
	PendingTransactions []*Transaction
}

func NewChain() *Chain {
	return &Chain{
		Blocks:              []*Block{GenesisBlock()},
		PendingTransactions: []*Transaction{},
	}
}

func GenesisBlock() *Block {
	return &Block{
		Index:     0,
		Timestamp: time.Now().Unix(),
		Hash:      []byte("genesis-hash"),
	}
}

func (c *Chain) AddBlock(block *Block) {
	if len(c.Blocks) > 0 {
		block.PrevHash = c.Blocks[len(c.Blocks)-1].Hash
	}
	block.Hash = block.CalculateHash()
	c.Blocks = append(c.Blocks, block)
}

func (c *Chain) AddTransaction(tx *Transaction) error {
	if !tx.Validate() {
		return errors.New("invalid transaction")
	}

	// Check for duplicates
	for _, t := range c.PendingTransactions {
		if bytes.Equal(t.Hash, tx.Hash) {
			return errors.New("transaction already exists")
		}
	}

	// Add to pending transactions
	c.PendingTransactions = append(c.PendingTransactions, tx)
	return nil
}

===========================================

File Path: ./pkg/blockchain/node.go
File Name: node.go

===========================================

// pkg/blockchain/node.go
package blockchain

import (
	"bytes"
	"errors"
	"sync"
)

type Node struct {
	Chain           *Chain
	Peers           []string
	mu              sync.RWMutex
	TransactionPool []*Transaction
	Address         string // Node's blockchain address for validation
	IsValidator     bool   // Whether this node is a validator
}

func NewNode() *Node {
	return &Node{
		Chain:           NewChain(),
		Peers:           make([]string, 0),
		TransactionPool: make([]*Transaction, 0),
	}
}

func (n *Node) AddTransaction(tx *Transaction) error {
	n.mu.Lock()
	defer n.mu.Unlock()

	// Verify transaction
	if !tx.Validate() {
		return errors.New("invalid transaction")
	}

	// Check for duplicates
	for _, t := range n.TransactionPool {
		if bytes.Equal(t.Hash, tx.Hash) {
			return errors.New("transaction already exists in pool")
		}
	}

	n.TransactionPool = append(n.TransactionPool, tx)

	// If we have enough transactions and we're a validator, create a block
	if len(n.TransactionPool) >= 5 && n.IsValidator {
		go n.CreateBlock()
	}

	return nil
}

func (n *Node) CreateBlock() *Block {
	n.mu.Lock()
	defer n.mu.Unlock()

	if len(n.TransactionPool) == 0 {
		return nil
	}

	prevBlock := n.Chain.Blocks[len(n.Chain.Blocks)-1]
	newBlock := NewBlock(
		prevBlock.Index+1,
		n.TransactionPool,
		prevBlock.Hash,
		n.Address,
	)

	n.Chain.AddBlock(newBlock)
	n.TransactionPool = []*Transaction{}

	return newBlock
}

===========================================

File Path: ./pkg/blockchain/block.go
File Name: block.go

===========================================

// pkg/blockchain/block.go
package blockchain

import (
	"crypto/sha256"
	"encoding/json"
	"time"
)

type Block struct {
	Index        int            `json:"index"`
	Timestamp    int64          `json:"timestamp"`
	Transactions []*Transaction `json:"transactions"`
	PrevHash     []byte         `json:"prev_hash"`
	Hash         []byte         `json:"hash"`
	Nonce        int            `json:"nonce"`
	Validator    string         `json:"validator"` // Address of the validator who created this block
}

func NewBlock(index int, transactions []*Transaction, prevHash []byte, validator string) *Block {
	block := &Block{
		Index:        index,
		Timestamp:    time.Now().Unix(),
		Transactions: transactions,
		PrevHash:     prevHash,
		Validator:    validator,
	}

	block.Hash = block.CalculateHash()
	return block
}

func (b *Block) CalculateHash() []byte {
	blockData := struct {
		Index        int
		Timestamp    int64
		Transactions [][32]byte // Using transaction hashes for efficiency
		PrevHash     []byte
		Validator    string
		Nonce        int
	}{
		Index:     b.Index,
		Timestamp: b.Timestamp,
		PrevHash:  b.PrevHash,
		Validator: b.Validator,
		Nonce:     b.Nonce,
	}

	// Extract transaction hashes
	txHashes := make([][32]byte, len(b.Transactions))
	for i, tx := range b.Transactions {
		copy(txHashes[i][:], tx.Hash)
	}
	blockData.Transactions = txHashes

	data, _ := json.Marshal(blockData)
	hash := sha256.Sum256(data)
	return hash[:]
}

===========================================

File Path: ./pkg/smartcontracts/election.go
File Name: election.go

===========================================

// pkg/smartcontracts/election.go
package smartcontracts

import (
	"github.com/koushamad/election-system/pkg/blockchain"
	"github.com/koushamad/election-system/pkg/election"
)

type ElectionContract struct {
	Chain *blockchain.Chain
}

func (ec *ElectionContract) CreateElection(e *election.Election) error {
	tx := blockchain.Transaction{
		Type: "create_election",
		Data: e,
	}
	return ec.Chain.AddTransaction(tx)
}

===========================================

File Path: ./pkg/election/ballot.go
File Name: ballot.go

===========================================

// pkg/election/ballot.go
package election

import (
	"github.com/cloudflare/bn256"
	"github.com/gtank/merlin"
	"github.com/koushamad/election-system/pkg/crypto"
)

type Ballot struct {
	Ciphertext []*bn256.G1
	ZKProof    []byte
	VoterID    string
}

func NewBallot(ciphertext []*bn256.G1, proof []byte, voterID string) *Ballot {
	return &Ballot{
		Ciphertext: ciphertext,
		ZKProof:    proof,
		VoterID:    voterID,
	}
}

func (b *Ballot) Validate() bool {
	transcript := merlin.NewTranscript("vote_proof")
	return crypto.VerifyZKProof(transcript, b.Ciphertext, b.ZKProof)
}

===========================================

File Path: ./pkg/election/election.go
File Name: election.go

===========================================

package election

import (
	"encoding/json"
	"time"

	"github.com/cloudflare/bn256"
)

type Election struct {
	ID         string
	Name       string
	Candidates []Candidate
	StartTime  time.Time
	EndTime    time.Time
	PublicKey  *bn256.G1
}

type Candidate struct {
	ID   string
	Name string
}

func (e *Election) Serialize() ([]byte, error) {
	return json.Marshal(e)
}

===========================================

